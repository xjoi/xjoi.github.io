<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/2018/11/22/bfs/"/>
      <url>/2018/11/22/bfs/</url>
      <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种线性数据结构，其结构就跟我们平时排队是一样的，有一个人在头，一个人在尾，队伍中的人当前都在队列中，我们注意到这种普通的队列可能会有两种操作</p><ul><li>删除一个头节点（排在第一的人完成了任务，走了）</li><li>插入一个尾节点（多一个人来排队）</li></ul><p>由上我们知道队列满足先进队先出队的性质，简称先进先出</p><p>在代码实现上我们一般用一个数组来模拟队列，用两个变量来模拟队列的头尾在数组中的位置</p><h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><blockquote><p>给你一个 nxm的地图，‘@’是你所在的位置，’#’是障碍，不能经过，’.’ 是空地，可以经过，你只能往上下左右四个方向行走，现在问你最多可以走到多少个位置，包括你自己所处的位置。</p></blockquote><pre><code>9 11.#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ...........输出：59</code></pre><p>这道题我们可以利用队列来扩展还没有访问过的空地，用一个二维数组来标记某个位置是否访问过，访问过的位置不用再管，每次从队列中取出一个队头元素，去看看它的上下左右是否还有新的空地，有的话就加入队尾，下面是代码实现</p><pre><code class="c">#include &lt;bits/stdc++.h&gt;using namespace std;struct node {    int x, y;    //队列中的每个元素的信息};char mp[100][100];node Q[1000]; // 保存队列的数组int vis[22][22];int dx[] = {1, 0, -1, 0};int dy[] = {0, 1, 0, -1};void bfs(int n, int m, int sx, int sy) {    int head = 0, tail = 0; // 队头的位置与队尾的位置    Q[tail].x = sx;    Q[tail].y = sy;    tail++;    vis[sx][sy] = 1; //一开始将起点放入队列开始广搜    while (head &lt; tail) { // 当队列非空时，不断取出队头的元素        node front = Q[head]; head++;        int nowx = front.x;        int nowy = front.y;        for (int i = 0; i &lt; 4; i++) { // 向队头元素的四周扩展            int tox = nowx + dx[i];            int toy = nowy + dy[i];            //越界检查 障碍判断 是否已经访问过            if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m || mp[tox][toy] == &#39;#&#39; || vis[tox][toy]) {                continue;            }            //发现新大陆            vis[tox][toy] = 1;            Q[tail].x = tox;            Q[tail].y = toy;            tail++;        }    }    printf(&quot;%d\n&quot;, tail);}int main() {    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int sx =-1, sy = -1;    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%s&quot;, mp[i]);                    for (int j = 0; j &lt; m; j++) {            if( mp[i][j] == &#39;@&#39;) {                sx = i;                sy = j;            }        }    }    bfs(n, m, sx, sy);    return 0;}</code></pre><p><strong>当然这还没有完全体现出队列的功能，下面我们再看一道例题</strong></p><h1 id="骑士出行"><a href="#骑士出行" class="headerlink" title="骑士出行"></a>骑士出行</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>告诉你一个棋盘的大小，问你从棋盘的一个点走到另一个点的最小步数，走的规则是国际象棋中骑士的走法，即走日字形</p></blockquote><p><img src="/img/knight.jpg" alt="knight"></p><p>我们观察第一个例题中的队列扩展的过程其实是由近及远扩展的，每一个新的节点都是以最少的步数扩展到的，这个很显然，因为一开始0步的能走到所有距离起点为1的点，所有距离起点为2的点都是由距离起点为1的点扩展到的，以此类推。<br>因此我们考虑在将每个点扩展进队列的时候顺便增加一个信息，就是这个点距离起点的距离，那么我们就可以在广搜的过程中顺便求出每个点到起点的最短路径了<br>因为在搜索的过程中队列的扩展形式是一层层往外扩展的，所以得名广度优先搜索</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;//八个方向int dx[] = {1, 1, 2, 2, -1, -1, -2, -2};int dy[] = {2, -2, 1, -1, 2, -2, 1, -1};int queue[90010][3]; // 保存队列，包含三个信息，x坐标，y坐标，与起点之间的距离int flag[310][310]; //标记某个点是否走过了int main() {        int t, n;        int bfs(int, int, int , int, int);        scanf(&quot;%d&quot;, &amp;n);        for(int i = 0; i &lt; n; i++) {                for(int j = 0; j &lt; n; j++) {                        flag[i][j] = 0;                }        }        int sx, sy, tx, ty;        scanf(&quot;%d%d%d%d&quot;, &amp;sx, &amp;sy, &amp;tx, &amp;ty);        int ret = bfs(sx, sy, tx, ty, n);        printf(&quot;%d\n&quot;, ret);        return 0;}int bfs(int sx, int sy, int tx, int ty, int n) {        if(sx == tx &amp;&amp; sy == ty) {                return 0;        }        flag[sx][sy] = 1;        int head = 0, tail = 0;        queue[tail][0] = sx;        queue[tail][1] = sy;        queue[tail][2] = 0;        tail++;        while(head &lt; tail) {                int x = queue[head][0];                int y = queue[head][1];                int step = queue[head][2];                head++;                for(int i = 0; i &lt; 8; i++) {                        int nowx = x + dx[i];                        int nowy = y + dy[i];                        if(nowx &lt; 0 || nowx &gt;= n || nowy &lt; 0 || nowy &gt;= n) {                                continue;                        }                        if(flag[nowx][nowy] == 1) {                                continue;                        }                        if(nowx == tx &amp;&amp; nowy == ty) {                                return step + 1;                        }                        flag[nowx][nowy] = 1;                        queue[tail][0] = nowx;                        queue[tail][1] = nowy;                        queue[tail][2] = step + 1; //距离等于搜到它的点的距离 加 1                        tail++;                }        }}</code></pre>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 广搜 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018noip题解以及点评</title>
      <link href="/2018/11/21/2018noip-solution/"/>
      <url>/2018/11/21/2018noip-solution/</url>
      <content type="html"><![CDATA[<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="T1-道路铺设"><a href="#T1-道路铺设" class="headerlink" title="T1-道路铺设"></a>T1-道路铺设</h2><p>暑假里给学生讲这种模型的时候讲到有四种方法可以做这样的题<br>1：RMQ<br>2：单调栈<br>3：迪卡尔树<br>4：看似暴力的预处理<br>就算没做过原题，不知道差分，随便写一种方法都不会花很长时间</p><h2 id="T2-货币系统"><a href="#T2-货币系统" class="headerlink" title="T2-货币系统"></a>T2-货币系统</h2><p>一看到这个题可能有点紧张，然后看看数据范围基本就能联想到背包<br>想到背包这个题基本就没有了秘密</p><h2 id="T3-赛道修建"><a href="#T3-赛道修建" class="headerlink" title="T3-赛道修建"></a>T3-赛道修建</h2><p>首先根据提高组选手的基本素养，立刻反应要二分<br>二分之后怎么验证呢<br>我们可以枚举路径的LCA，那么一条合法路径就被分成了两条从LCA出发的路径，当然如果某条从LCA出发的路径足够长，自己也可以构成一条路径<br>我们发现每个子树要么自己配对完毕，要么留下一条路径延伸到父亲方向去<br>留下两条或以上没有意义<br>因此如果实在要留，我们尽可能留下最长的那条路径<br>只要两条路径的长度加起来&gt;=K就可以配成一对，因此现在变成了一个子问题<br>给你一个数组，问你最多配成多少对的和&gt;=K的整数对<br>从小到大枚举每个数然后在set里面二分找最小的数去陪对就好了</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55555;vector &lt;pair&lt;int, int&gt; &gt; e[N];int n, m;int w[N];int total;void dfs(int u, int f, int x) {    if (total &gt;= m) {        return ;    }    multiset &lt;int&gt; st;    for (auto it : e[u]) {        if (it.first != f) {            dfs(it.first, u, x);            if (total &gt;= m) {                return ;            }            int value = w[it.first] + it.second;            if (value &gt;= x) {                total++;            } else {                st.insert(value);            }        }    }    if (total &gt;= m) {        return ;    }    int left = 0;    while (!st.empty()) {        auto it = st.begin();        int value = *it;        st.erase(it);        if (*it &gt;= x) {            total ++;            continue;        }        auto it_pair = st.lower_bound(x - *it);        if (it_pair == st.end()) {            left = max(left, value);        } else {            total ++;            st.erase(it_pair);        }    }    w[u] = left;}bool judge (int x) {    total = 0;    dfs(0, -1, x);    return total &gt;= m;}int main () {    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int a, b, c;    for (int i = 1; i &lt; n; i++) {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        a--; b--;        e[a].push_back(make_pair(b, c));        e[b].push_back(make_pair(a, c));    }    int l = 1, r = 500000000, best = -1;    while (l &lt;= r) {        int mid = (l + r) &gt;&gt; 1;        if (judge (mid)) {            best = mid;            l = mid + 1;        } else {            r = mid - 1;        }    }    printf(&quot;%d\n&quot;, best);    return 0;}</code></pre><h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="T1-旅行"><a href="#T1-旅行" class="headerlink" title="T1-旅行"></a>T1-旅行</h2><p>树的情况显然可以直接贪心每次走编号小的儿子<br>图的情况，稍微分析一下发现有一条边可以不走，然后看到数据范围就可以想到暴力枚举了</p><h2 id="T2-填数游戏"><a href="#T2-填数游戏" class="headerlink" title="T2-填数游戏"></a>T2-填数游戏</h2><p>首先打出8*7以内的表,然后发现</p><p>$$ f[n][m]= 3* f[n][m - 1] (m &gt;= n-2) $$</p><p>那么我们只需要搞出8x9以内的就万事大吉<br>那么我们开个O2大力打出8x8的表，你会发现</p><p>$$f[n][n+1] = f[n][n] * 3 + d$$<br>d是个等比数列，然后8x9的答案可以推算出来<br>8×8需要跑一小会，搜索写的好一点可以更快地打出8x8</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = (int)1e9+7;vector &lt;pair&lt;int,int&gt; &gt; v[100];int a[8][8];int cnt;int n, m;bool check() {    for (int i = 1; i &lt; n; i++) {        for (int j = 1; j &lt; m; j++) if (a[i - 1][j] == a[i][j - 1]){            for (int xie = i + j + 1; xie &lt; n + m - 1; xie++) {                int col = -1;                int state = 0;                for (int k = 0; k &lt; v[xie].size(); k++) {                    auto it = v[xie][k];                    if (it.first &gt;= i &amp;&amp; it.second &gt;= j) {                        state |= (1 &lt;&lt; a[it.first][it.second]);                    }                    if (state == 3) {                        return false;                    }                }            }        }    }    return true;}void dfs(int tot, int now) {    //printf(&quot;tot=%d now=%d\n&quot;, tot, now);    if (now == tot) {        if (check()) {            cnt++;        }        return ;    }    for (int i = 0; i &lt; v[now].size(); i++) {        pair&lt;int,int&gt; it = v[now][i];        a[it.first][it.second] = 1;    }    dfs(tot, now + 1);    for (int i = 0; i &lt; v[now].size(); i++) {        pair&lt;int,int&gt; it = v[now][i];        a[it.first][it.second] = 0;        dfs(tot, now + 1);    }}int brute(int n, int m) {    ::n = n;    ::m = m;    cnt = 0;    for (int i = 0; i &lt; 100; i++) v[i].clear();    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; m; j++) {            v[i+j].push_back(make_pair(i, j));        }    }    dfs(n + m - 1, 0);    return cnt;} int biao[][10] = { {2,4,8,16,32,64,128,256}, {4,12,36,108,324,972,2916,8748}, {8,36,112,336,1008,3024,9072,27216}, {16,108,336,912,2688,8064,24192,72576}, {32,324,1008,2688,7136,21312,63936,191808}, {64,972,3024,8064,21312,56768,170112,510336}, {128,2916,9072,24192,63936,170112,453504,1360128}, {256,8748,27216,72576,191808,510336,1360128,3626752, 10879488}};int pow_mod(int a, int b) {    int ret = 1;    while (b) {        if (b &amp; 1) {            ret = 1LL * ret * a % mod;        }        a = 1LL * a * a % mod;        b &gt;&gt;= 1;    }    return ret;}int main () {    /*    for (int i = 8; i &lt;= 8; i++) {        printf(&quot;i=%d\n&quot;, i);        cout &lt;&lt; &#39;{&#39;;        for (int j = 8; j &lt;= 8; j++) { //           printf(&quot;i=%d j=%d\n&quot;, i, j);            printf(&quot;%d, \n&quot;, brute(i, j));        }        cout &lt;&lt; &#39;}&#39; &lt;&lt; endl;    }*/    biao[6][8] = biao[6][7] * 3;    biao[6][9] = biao[6][8] * 3;    biao[7][9] = biao[7][8] * 3;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    if (n == 1) {        cout &lt;&lt; pow_mod(2, m) &lt;&lt; endl;        return 0;    }    n --;    m --;    if (m &gt;= 7 &amp;&amp; m &gt;= n + 2) {        cout &lt;&lt; 1LL * biao[n][n + 2] * pow_mod(3, m - n - 2) % mod;    } else {        cout &lt;&lt; biao[n][m]  &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="T3-保卫王国"><a href="#T3-保卫王国" class="headerlink" title="T3-保卫王国"></a>T3-保卫王国</h2><p>首先，只要会基本的树形DP就可以拿到44分</p><p>对于正解，我们先观察一下钦点一个点的状态的时候该怎么做<br>如果钦点了一个点的状态，我们需要自底向上DP一遍，然后再从上往下再DP一遍<br>这样子我们可以预处理出两个东西<br>f[u][0/1]: u选或者不选的情况下u子树的最优值<br>g[u][0/1]：u选或者不选的情况下整棵树的最优值</p><p>然后再进一步，我们来思考钦点两个点怎么做</p><p>我们发现钦点两个点其实就是会影响这两个点的LCA子树内的DP状态，把这个子树拿掉后的其他点的代价可以利用前面处理出来的数组快速算出来</p><p>于是就可以考虑用倍增算法来预处理出如下数组</p><p>qd[i][j][x][y]<br>表示j的状态为x,j的2的i次方个祖先的状态为y的情况下的最优值，这个dp满足区间合并的性质，合并起来类似于矩阵乘法的转移</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 300010;const int MAX_POW = 19;const long long INF = (long long) 1e12;vector &lt;int&gt; e[N];int val[N], dep[N];int p[MAX_POW][N];long long f[N][2], g[N][2];struct state{    long long a[2][2];    void init() {        a[0][0] = a[0][1] = a[1][1] = a[1][0] = INF;    }    void print() {        for (int i = 0; i &lt; 2; i++) {            for (int j = 0; j &lt; 2; j++) {                printf(&quot;a[%d][%d] = %lld\n&quot;, i, j, a[i][j]);            }        }        puts(&quot;&quot;);    }}qd[MAX_POW][N];int n, m;void input () {    scanf(&quot;%d%d%*s&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%d&quot;, &amp;val[i]);    }    int a, b;    for (int i = 1; i &lt; n; i++) {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        a--; b--;        e[a].push_back(b);        e[b].push_back(a);    }}void dfs(int u, int pre) {    if(pre != -1) dep[u] = dep[pre] + 1;    p[0][u] = pre;    f[u][0] = 0;    f[u][1] = val[u];    for (auto v: e[u]) if (v != pre){        dfs(v, u);        f[u][0] += f[v][1];        f[u][1] += min(f[v][0], f[v][1]);    }}void rdfs(int u, int pre, int pf0, int pf1) {    g[u][0] = f[u][0] + pf1;    g[u][1] = f[u][1] + min(pf0, pf1);    for (auto v: e[u]) if (v != pre) {        qd[0][v].a[0][0] = INF;        qd[0][v].a[0][1] = qd[0][v].a[1][1] = f[u][1] - min(f[v][0], f[v][1]);        qd[0][v].a[1][0] = f[u][0] - f[v][1];        rdfs(v, u, g[u][0] - f[v][1], g[u][1] - min(f[v][0], f[v][1]));    }}state merge(const state&amp; A, const state&amp; B) {    state res;    for (int i = 0; i &lt; 2; i++) {        for (int j = 0; j &lt; 2; j++) {            res.a[i][j] = INF;            for (int k = 0; k &lt; 2; k++) {                res.a[i][j] = min(res.a[i][j], A.a[i][k] + B.a[k][j]);            }        }    }    return res;}void init() {    memset(p, -1, sizeof(p));    dfs(0, -1);    for (int i = 1; i &lt; MAX_POW; i++) {        for (int u = 0; u &lt; n; u++) {            p[i][u] = p[i - 1][p[i - 1][u]];        }    }    rdfs(0, -1, 0, 0);    for (int i = 1; i &lt; MAX_POW; i++) {        for (int u = 0; u &lt; n; u++) {            qd[i][u] = merge(qd[i-1][u], qd[i-1][p[i - 1][u]]);        }    }}void query() {    int ua,x,ub,y;    for (int i = 0; i &lt; m; i++) {        scanf(&quot;%d%d%d%d&quot;, &amp;ua, &amp;x, &amp;ub, &amp;y);        ua--; ub--;        if (dep[ua] &lt; dep[ub]) {            swap(ua, ub);            swap(x, y);        }        int delta = dep[ua] - dep[ub];        state left; left.init(); left.a[x][x] = f[ua][x];        state right; right.init(); right.a[y][y] = f[ub][y];        for (int i = MAX_POW - 1; i &gt;= 0; i--) if (delta &gt;&gt; i &amp; 1){            left = merge(left, qd[i][ua]);            ua = p[i][ua];        }        if (ua == ub) {            long long res = left.a[x][y];            int fa = p[0][ub];            if (fa != -1) {                long long c0 = g[fa][0] - f[ub][1];                long long c1 = g[fa][1] - min(f[ub][0], f[ub][1]);                if (y == 0) {                    res += c1;                } else {                    res += min(c0, c1);                }            }            printf(&quot;%lld\n&quot;, res &gt;= INF ? -1 : res);        } else {            for (int i = MAX_POW - 1; i &gt;= 0; i--) if (p[i][ua] != p[i][ub]) {                left = merge(left, qd[i][ua]);                right = merge(right, qd[i][ub]);                ua = p[i][ua];                ub = p[i][ub];            }            int lca = p[0][ua];            long long c0 = g[lca][0] - f[ua][1] - f[ub][1];            long long c1 = g[lca][1] - min(f[ua][0], f[ua][1]) - min(f[ub][0], f[ub][1]) ;            c0 += left.a[x][1] + right.a[y][1];            c1 += min(left.a[x][0], left.a[x][1]) + min(right.a[y][0], right.a[y][1]);            printf(&quot;%lld\n&quot;, min(c0, c1) &gt;= INF ? -1 : min(c0, c1));        }    }}int main() {    input();    init();    query();    return 0;}</code></pre><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><p>day1三题属于送分题，尤其T1有四五种方法可以做, T2只要大力背包，T3这种二分之后树上贪心的套路也已经屡见不鲜</p><p>day2-T1考察图论基本功，T2没有什么思路首先都会去打表，而且这个题打出8*7以内的表非常容易，几分钟就能跑出答案，观察这个表的规律就可以拿到大部分的分数了，T3比较坑，这本来就是一道原题，而且这种第一次见基本做不出来的题出在了一场决定很多选手命运的比赛中确实不太合适，尽管暴力分给的还算多</p><p>总的来说，今年的题目远远不及前两年, 原题或者类原题实在多了点,思维上也没有什么亮点</p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello-world</title>
      <link href="/2018/11/21/hello-world-md/"/>
      <url>/2018/11/21/hello-world-md/</url>
      <content type="html"><![CDATA[<h1 id="开启新世界的程序"><a href="#开启新世界的程序" class="headerlink" title="开启新世界的程序"></a>开启新世界的程序</h1><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main() {    printf(&quot;hello world\n&quot;);    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的一些入门必备知识</title>
      <link href="/2018/11/21/tree-basic/"/>
      <url>/2018/11/21/tree-basic/</url>
      <content type="html"><![CDATA[<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1>]]></content>
      
      <categories>
          
          <category> 提高 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> dfs序 </tag>
            
            <tag> 重心 </tag>
            
            <tag> 直径 </tag>
            
            <tag> 欧拉序列 </tag>
            
            <tag> 最近公共祖先 </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018noip游记</title>
      <link href="/2018/11/13/2018noip/"/>
      <url>/2018/11/13/2018noip/</url>
      <content type="html"><![CDATA[<h1 id="day-6-7-8"><a href="#day-6-7-8" class="headerlink" title="day -6 -7 -8"></a>day -6 -7 -8</h1><p>编写本次比赛需要用到的所有脚本，linux一份，windows一份<br>考虑各种作弊的可能性，并结合软硬件消除所有能想到的作弊方法,这个会在下文给出<br>下面进入本次noip精(dar)彩(k)连续剧情</p><h1 id="day-5-晚"><a href="#day-5-晚" class="headerlink" title="day -5 晚"></a>day -5 晚</h1><p>“操作系统好像是64位的，不行，全部都得改成32位的”</p><p>“%^$#@*&amp;~”</p><p>“今晚通宵重新做母盘，明天全部重新克隆”</p><p>“笔记本好像没有克隆技术，只能一台台用U盘/移动硬盘 刻”</p><p>“&amp;^%$!@#!$!%%^^%”</p><h1 id="day-4"><a href="#day-4" class="headerlink" title="day -4"></a>day -4</h1><p>全盘镜像失败，去紫金港那边查看情况，经过一个上午的努力，windows总算能刻录了，但是双系统依然无法刻录<br>各种尝试失败后发现直接取代原有双系统种的windows，并不会影响linux，启动引导都还在，反正linux并不需要做任何的配置与软件安装，于是就决定对720台电脑全部修改windows系统。<br>刻了大概20台电脑时突然发现没有装还原软件，重新装好，继续重新刻，还好不是刻完了才发现这个问题<br>装还原软件的时候，随手设了一个比较长的密码，事实证明，这是个错误的决定。。。<br>到了晚上11点时，大概已经有五六百台电脑已经刻好，第二天准备进入紫金港校区开始实地联网测试</p><h1 id="day-3"><a href="#day-3" class="headerlink" title="day -3"></a>day -3</h1><p>上午</p><p>到了现场，发现桌子不够长，每个人只有60公分长，比赛的时候很容易互相伤害。<br>于是赶紧加桌子<br>等720台电脑送到时，已经是接近中午，帮着卸货，扛了一会儿电脑。。连续熬夜表示体力不支</p><p>下午</p><p>技术上的测试还完全做不了，只能先干点杂活了。<br>首先开始摆放电脑，摆了一个双系统区的电脑，想进行简单的网络连通性测试，不过网线，电源线，都需要人手来连接<br>与网络负责人交接网络的布局，本来是准备每个区120台电脑，各自一个局域网，实际到了现场一看发现不现实，<br>那样的话每个局域网收发试卷都需要有人在，由于网络异常，死机等问题导致程序卡住了，都需要及时作出调整，那就至少需要六个人盯着<br>由于人手很明显不够，于是决定所有的网络汇聚到主席台上，直接在主席台上摆放7台服务器，每台负责一个区域，5个windows区，一个windows/linux混合区<br>事实证明，这个选择非常正确，因为到了比赛当天，周老师被调去负责另外多出来的一个机房了，于是现场就剩下了我和余姚中学过来帮忙的一行兄。</p><p>于是当天就在杂七杂八的事情中过去了，跟比赛相关的测试还完全没有动过。</p><h1 id="day-2"><a href="#day-2" class="headerlink" title="day -2"></a>day -2</h1><p>一整天都在ping ip中度过, 那几天做梦都在ping ip<br>现场测试发现网络不通的主要原因有网线松了，交换机没配好，电脑没电了，ip没设对等<br>碰到网络连不上，就得一台台看过去, 于是这里需要一些人手，当晚应该是联通了几个区的网络的，还剩一两个区没动</p><h1 id="day-1"><a href="#day-1" class="headerlink" title="day -1"></a>day -1</h1><p>考前压力测试，造成了一定程度的混乱，这里就不多说了<br>day -1 也继续在调网络，顺便对几个区块进行了考试的模拟。批量下发题目，收代码，D盘备份等。网络通的几个区域是比较顺利的<br>利用现场几百台电脑，顺便优化了一下代码，调了调参数。</p><h1 id="day0"><a href="#day0" class="headerlink" title="day0"></a>day0</h1><p>mac地址绑定，以及绑定后的重新测试，已经是最后一天了。时间非常紧张<br>为什么要做绑定呢？这样可以避免因为选手发现现场IP设置的规律，而把ip改成对方的ip，或者选手瞎改ip造成ip地址冲突影响别人<br>结合代码，每个ip只收取这个ip对应考号的文件夹，如果考生改变了D盘下的文件夹名字，这台电脑的成绩就会作废<br>linux下不需要做设置，因为用户名就是考号，考生没有权限修改用户名<br>在技术没做到位的情况下，可能的作弊方案是: 两个人day1看到自己的ip，day2互换ip，以及互改考生文件夹，这样在服务器上收上来看就好像什么都没发生一样<br>然后其他的作弊方法应该就是去厕所交换思路了或者上完厕所回来换了个位置了，这属于监考老师管理的范畴了<br>晚上九点，网络终于全线联通了，真是令人感动, 差一点点就GG了，所有的事情都差那么一点点药丸<br>当晚周老师通宵编辑每个服务器上的ip-用户对照表以及重新测试网络，记录有问题的电脑，我实在扛不住，去睡了四五个小时</p><h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><p>正式比赛开始，看见将近700个考生齐刷刷的走进来，想想昨天晚上所有的工作才就绪…<br>由于网络是通的，发卷没有出现太大问题<br>OI比赛没有太多看头，考完考生也没法留在赛场上合影之类的，相对ICPC来说乐趣少了很多<br>比赛过程中有些选手说dev编译出了问题，去看了一下一般是没有选择编译成32位的下拉菜单<br>这次比赛其实给windows选手准备了好几个编辑器的，比如gvim,sublime,vscode<br>不过大家好像都只会一键编译，并不会使用命令行编译，这个会让选手吃一些亏，因为考前须知里面明确写了环境变量的g++编译器版本是4.8.4，这个版本与评测机的版本一致<br>比较科学的做法是最后都要用这个版本把所有的程序编译一遍看看会不会CE<br>发现还有一些选手非常依赖于单步调试，ide一变，可能就不适应了。<br>还有一些奇怪的问题。<br>比如cpp文件默认显示的图标不是dev的图标，这个怎么办</p><p>12点一到，比赛结束，考生离场，开始收卷</p><p>收卷过程非常顺利，十几分钟时间，所有的代码都已经收完，接下来开始合并服务器上收到的代码<br>收代码的过程要收两份，一份是整个D盘下的所有文件，linux则是整个主文件夹下的所有文件<br>第二份是只与考试相关的考生文件夹下的内容，并且要尽可能的去除无关文件<br>做法就是先收备份，然后从备份里面筛选出需要的内容上交给CCF<br>由于一些选手比赛过程中采用了打表等手段，备份文件可能会非常大<br>加上第一天没经验，忘了过滤回收站，于是有些选手的回收站中的几万个文件也被收了上来</p><p>提高组day1由于汇总试卷与检查环节花了很长时间，导致普及组考试开始前的二十分钟才清空好所有电脑，并下发试卷</p><p>2：30 普及组比赛正式开始<br>受制于初中教学资源的匮乏，普及组用pascal的选手还是非常多的，一般的问题都是跟IDE有关，可能部分选手在家里用的版本跟考试的版本不太一样，就无法适应<br>这种情况一般就是让选手使用备选软件里面的其他版本的IDE</p><p>其中有个小孩，比赛过程中似乎碰到了一些小问题，我也不记得了，过去的时候他很紧张，帮他解决完之后，小家伙谢谢谢谢的说个不停</p><p>赛后做了一个编译检查，查有没有乱码，结果发现普及组爆0的情况非常多，大部分是文件名打错或者目录建错，实在是太惨了。<br>要不以后还是跟初中生一起玩吧，感觉他们更需要支持。</p><h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p>本来想day1晚上就把所有准备工作做好的，结果突然被拉去吃饭，于是那天晚上准备工作就没做<br>到了day2的早上，我发现linux区加用户的功能出了点问题，可能day1的时候改过代码，调来调去都不太行，还好有周老师在帮忙发完了ABCDE区的所有试卷<br>这时候他去另一个机房了，我好像还没有把代码改对，由于没有加版本控制，之前的版本也找不回来了，离选手入场大概还有十分钟，我假装什么事情也没有发生<br>周围人好像也不知道我这边发不了卷。<br>然后我冷静了一下，好像邮箱里面还剩下一份之前测试成功过的代码，于是赶紧下载下来，跑了跑还能用<br>于是立刻创建用户，发卷，重启<br>于是就发生了linux用户刚进场，电脑正在重启的一幕，据说把本校的一个小女生给吓坏了…</p><p>比赛过程十分顺利，没有出现什么奇怪的问题</p><p>这次day2我们经过day1的总结，计划在一个小时内完成所有的收卷汇总检查工作<br>12：30左右收完所有区域的代码（有几个选手考试的时候由于电脑问题，有加时）<br>然后这次我们先不筛选代码，直接将选手文件夹交给赵主任，然后自己这边同步筛选，这样就是双线程工作了，筛选完成后，一行兄那边立刻开始在noilinux上跑编译检查<br>效率非常高，最终一个小时不到完成任务</p><p>由于本次比赛是在一个环境里面，所以基本没有看到过乱码的现象，不过也不知道有没有漏网之鱼<br>反正我们是把编译错误的代码一份份的点开看了一遍，都没有发现问题</p><p>具体还要等待选手申诉看看还有没有什么锅，明年继续完善</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整整五天五夜，每个环节都差点出事情，幸好在一些最后关头都如有神助，网络通了，代码找到了。。。<br>没有周老师在我扛不住的时候熬夜干活，没有负责网络的叶同学的鼎力支持，没有余姚中学诸一行老师的火线救援，没有硬件部门的兄弟们一起通宵刻盘<br>本次比赛都没办法顺利举行</p><p>对于现场比赛来说，比赛的体验高于一切</p><p>希望大家通过这次ZJNOIP能感受到体验的重要性</p><p>中学生还是需要更多的机会的，区区一次联赛，实在是少的可怜，而且赛制还这么残酷</p><p>期待着搞一次面向中学生的IOI+ICPC赛制，一定会非常有趣, 至少比COI有趣多了</p><p>下面是一些赛场图片<br><img src="/img/2018noip1.jpg" alt="name"><br><img src="/img/2018noip2.jpg" alt="name"><br><img src="/img/2018noip3.jpg" alt="name"><br><img src="/img/2018noip4.jpg" alt="name"><br><img src="/img/2018noip5.jpg" alt="name"><br><img src="/img/2018noip6.jpg" alt="name"></p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018noip </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2018/09/23/bubble-sort-md/"/>
      <url>/2018/09/23/bubble-sort-md/</url>
      <content type="html"><![CDATA[<h1 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h1><blockquote><p>假设我们现在要按照从小到大的顺序排,每一轮我们都比较相邻元素的大小,如果前面的元素比较大,就交换,那么第一轮下来最大的数字肯定能跑到最后面去,接下来的每一轮我们都这样执行,那么第二轮,第二大的数会跑到倒数第二个数的位置去…第三轮..,n-1轮之后,整个序列就会变成有序的,每次相当于冒出一个最大的数来,因此叫做冒泡排序<br>复杂度<br>$$<br>O(n^2)<br>$$</p></blockquote><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[1010];int main() {    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%d&quot;, &amp;a[i]);    }    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n - i - 1 ; j++) { //最后面i个数是已经冒出来的i个数，不用再比较了            if (a[j] &gt; a[j + 1]) {                swap(a[j], a[j + 1]);            }        }    }    for (int i = 0; i &lt; n; i++) {        printf(&quot;%d &quot;, a[i]);    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我从哪里来</title>
      <link href="/2018/08/25/hexo-github/"/>
      <url>/2018/08/25/hexo-github/</url>
      <content type="html"><![CDATA[<h1 id="linux下安装环境"><a href="#linux下安装环境" class="headerlink" title="linux下安装环境"></a>linux下安装环境</h1><blockquote><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs下载</a></li><li>下载之后解压到合适的目录，假设放到/home/xjoi/nodejs/下</li></ul></blockquote><pre><code>sudo gedit /etc/profile# 在底部添加export NODE_HOME=/home/xjoi/nodejs/node-v10.13.0-linux-x64/binexport PATH=$NODE_HOME:$PATH保存退出sudo source /etc/profile验证版本node -vnpm -v安装hexo: npm i -g hexo &amp;&amp; npm install hexo --save</code></pre><h1 id="github-相关"><a href="#github-相关" class="headerlink" title="github 相关"></a>github 相关</h1><p>注册github账号,注意验证好邮箱<br>假设账号名字为yourname<br>在你的github中新建一个仓库,名字为 yourname.github.io</p><p>打开gitbash</p><pre><code>git config --global user.name &quot;账户名&quot;git config --global user.email &quot;github验证的邮箱名&quot;ssh-keygen -t rsa -C &quot;github验证的邮箱名&quot; (默认按回车即可)</code></pre><p>将~/.ssh/id_rsa.pub中的内容复制到github网页端-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key<br>完成后在bash中输入</p><pre><code>ssh -T git@github.com输入yes即可</code></pre><p>设置成功返回</p><pre><code>Hi xxxxxxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><pre><code>hexo init myblogcd mybloghexo s</code></pre><p>打开<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a> 检验是否初始化成功</p><h1 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h1><p>在themes文件夹里面放上主题文件,比如3-hexo主题</p><pre><code>git clone https://github.com/xjoi/hexo-theme-3-hexo themes/3-hexo</code></pre><p>修改 myblog/_config.yml文件,将theme后面的landscape改为3-hexo,更多主题参考<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网</a></p><pre><code>hexo g &amp;&amp; hexo s</code></pre><p>输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>, 查看主题是否加载成功</p><h1 id="将博客部署到github上"><a href="#将博客部署到github上" class="headerlink" title="将博客部署到github上"></a>将博客部署到github上</h1><p>在myblog目录下安装hexo-deployer-git</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>修改myblog/_config.yml最后几行,注意空格要严格一样</p><pre><code>deploy:  type: git  repo: https://github.com/yourname/yourname.github.io.git  branch: master</code></pre><p>部署</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>稍等一会儿在浏览器中输入yourname.github.io查看是否发布成功</p><h1 id="设置博客模板"><a href="#设置博客模板" class="headerlink" title="设置博客模板"></a>设置博客模板</h1><p>修改 scaffolds下的post.md</p><pre><code>---title: {{ title }}date: {{ date }}categories:tags:---</code></pre><h1 id="发表博客"><a href="#发表博客" class="headerlink" title="发表博客"></a>发表博客</h1><pre><code>hexo new post xxx</code></pre><p>会自动生成一个以xxx为title的markdown文件,编辑这个文件即可</p><h1 id="网站的备份"><a href="#网站的备份" class="headerlink" title="网站的备份"></a>网站的备份</h1><p>发布到github上面的内容是不带原有的markdown文件的,发布的是解析后的html文件</p><p>因此为了满足异地的写作与发布,我们应该要将本地的内容以及相关的配置备份一下</p><p><a href="https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/" target="_blank" rel="noopener">备份</a></p><pre><code>git clone https://github.com/yourgithubname/yourgithubname.github.comcd yourgithubnamenpm install hexo-clinpm installnpm install hexo-deployer-git</code></pre><h1 id="网站信息修改"><a href="#网站信息修改" class="headerlink" title="网站信息修改"></a>网站信息修改</h1><p>编辑myblog/_config.yml文件</p><pre><code>title: 网站名字author: 作者url: 网站网址</code></pre><h1 id="文末声明"><a href="#文末声明" class="headerlink" title="文末声明"></a>文末声明</h1><p>编辑<code>3-hexo/_config.yml</code>文件,找到文末声明的地方,修改自己的邮箱</p><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>编辑 <code>node_modules\marked\lib\marked.js</code> 脚本<br>处理markdown与mathjax的冲突<br>如果要显示数学公式,可以在最开头加上mathjax: true</p><pre><code>451行左右(随着版本的更新可能有波动)escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/,改为escape: /^\\([`*\[\]()# +\-.!_&gt;])/,459行左右em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,改为em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><p>首先关闭myblog/_config.yml中的高亮设置</p><pre><code>highlight:  enable: false</code></pre><p>配置3-hexo/_config.yml中的高亮设置：</p><pre><code>highlight:  on: true # true开启代码高亮  lineNum: true # true显示行号  theme: atom-dark</code></pre><h1 id="头像与文章列表背景"><a href="#头像与文章列表背景" class="headerlink" title="头像与文章列表背景"></a>头像与文章列表背景</h1><blockquote><p>替换themes/3-hexo/source/img 下面的avatar.jpg (头像)<br>替换themes/3-hexo/source/img 下面的background.jpg(文章列表背景图片)</p></blockquote><h1 id="友链与评论"><a href="#友链与评论" class="headerlink" title="友链与评论"></a>友链与评论</h1><p>编辑themes/3-hexo/_config.yml文件</p><blockquote><p>链接图标link: 修改github地址<br>友情链接friends: 增加自己朋友的blog地址<br>评论: comment : 开启设置为true, 选择gitalk ,在下方gitalk下面填入相应信息</p><pre><code>注册: https://github.com/settings/applications/new</code></pre></blockquote><p><img src="/img/auth.png" alt="image"></p><p>编辑3-hexo/_config.yml</p><pre><code>gitalk:  githubID: xjoi #git账户名  repo: xjoi.github.io #仓库名  ClientID: af0e91f8b3e07b208cc7 #上一步得到的信息  ClientSecret: 20b655d18155c0ee2c3093b8be4b91f15d444c3b  adminUser: becauseofyou # 仓库管理员账号名</code></pre><h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><p>找到3-hexo/_config.yml 中searchAll: 有提示</p><pre><code>searchAll: true# true 启用全文搜索# 开启此功能需要下面操作：# 1. 在 hexo 根目录 执行 npm install hexo-generator-search --save 安装插件# 2. 在 hexo 根目录的 _config.xml 中添加下面内容# search:#   path: search.xml#   field: post</code></pre><h1 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h1><p>同上</p><pre><code>word_count: true# true 开启字数统计# 开启此功能需要安装插件 ：在 hexo根目录 执行npm i hexo-wordcount --save</code></pre><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片放在/img目录下面，引用的时候只需要</p><pre><code>![name](/img/test.png)</code></pre>]]></content>
      
      <categories>
          
          <category> 辅助技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
