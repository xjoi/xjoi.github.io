---
title: 第一届校赛题解
date: 2018-12-09 19:43:59
categories:
- 比赛
tags:

mathjax: true
---

# A-easymath

找出所有x的约数然后看他们的最小公倍数是否是x即可

# B-permutation

听说赛场上有人直接打表找规律过了此题？太强了。

这题本着送温暖的目的，被找到规律了也没事。

讲讲科学些的做法：

首先，要清楚一点：排列和置换是可以一一对应的，而且如果假设有点 1...n ，将所有的边 $(i,p_i)$ 连接起来，那么一个排列就对应一个由若干个环构成的图。

假设我们要算的是所有排列的贡献和。

我们考虑算出每一个数字对于答案的贡献。假设当前数字存在于一个大小为 $t (t\leq n)$ 的环中，那么有 $\binom{n-1}{t-1}(t-1)!(n-t)!$ 种可能。而 $\binom{n-1}{t-1}(t-1)!(n-t)!=(n-1)!$ 。如果这个数有贡献，那么当且仅当 $t$ 是 $k$ 的因数。设 $x$ 为小于等于 $n$ 的 $k$ 的因数，那么 1...n 的任何一个数都对答案有 $(n-1)!x$ 的贡献。所以总贡献为 $n!x$ 。

由于题目要求的是期望，所以答案要除以 $n!$ ，于是答案就是 $x$ —— 小于等于 $n$ 的 $k$ 的因数个数。

于是题目中的模数其实并没什么用，只是个障眼法。题目中的 $n,k$ 数据范围可以开的更大，只开 1e9 的也只是个障眼法。


# C-glance

直接for循环按照题意模拟即可

# D-sequence


我们考虑如何 $O(n)$ 求出一个序列的不同子序列种数。

令 $dp_i$ 表示前 $i$ 个数字组成的序列的不同子序列种数，则 $dp_{i+1}=2dp_i-dp_{last_{a_{i+1}}-1}$ 。其中 $last_{a_{i+1}}$表示上一次 $a_{i+1}$ 出现之前的 DP 值。

表示的意义是：第 $i$ 位在子序列中可以选择不选或者选，但是有 $dp_{last_{a_{i+1}}}$ 种情况重复了，要减掉。

时间复杂度 $O(nm)$ 。

考虑把 dp 转移采用矩阵的形式，不难写出对于每一种 $a_i$ 的转移矩阵。由于 $a_i$ 的取值只有 $4$ 种，构造矩阵，令前 $4$ 列分别为对应的数的 $dp_{last_{v}-1}$ 值，第 $5$ 列表示 DP 值，所以转移矩阵的长宽为 $L=5$ ，则我们可以用线段树维护区间转移矩阵乘积。为了支持修改，我们需要预处理矩阵的幂。

时间复杂度 $O(L^3 m \log n )$ 。


# E-game

先暴力找到总共的轮数z，得分总和为x+y

那么每轮的得分为

1 3 5 7 ... 2z-1

那么我们需要判断这里面最少需要几个数加起来等于x

从小到大枚举答案cnt

我们我们取cnt个数，他们的和可以凑成的最小值是前面cnt个数，最大值是后面cnt个数，显然最小值和最大值的奇偶性是一样的，稍微再思考一下我们会发现，最小值+2，最小值+4，最小值+6...一直到最大值这些数我们都可以拼成

所以我们只需要判断x是否在最小值和最大值之间以及x的奇偶性与最小值是否一致即可

# F-candle

由于总点数比较小，我们只需要大力状压枚举选择了那些叶子结点然后模拟题意

# G-string

考察KMP算法next数组的应用，没学过的去学学吧

# H-hex

首先建图，将每个六边形看成一个点，发现三个六边形有一个公共顶点就给这三个点建边，整个图会形成若干个联通块，我们依次放置同一个联通块内每一个点的标记，我们发现每一个标记都可以到达联通块内的任意一个地方，于是第一个点有cnt种标记可以放，第二个点有cnt-1种标记可以放..

但是要注意最后联通在一起的三个点只有三种方案可以放

所以答案为
$cnt \times (cnt-1) \times ... \times 3 $

# I-stars

模拟题

# J-memory


#### 算法一

我会$O(n^4)$暴力！这种情况应用于没有人愿意验题时出题人的自救行为。

#### 算法二

一个直观的想法是，如果一个数不能和其余的$n-1$个数羁绊，这个数不会出现在答案区间。

那么我们一开始保留整个区间。如果区间中所有的数都能被羁绊，直接更新答案。否则，找到一个不能被羁绊的数删除，划分为两个区间处理。

数据结构大师这时候就可以直接强上了。对于每个数记录前一个可以羁绊它的数$pre_i$和后一个可以羁绊它的数$nex_i$，只需要在当前区间中查找满足以下条件的数i：

$ l <= i <= r $，$ pre_i < l $，$ nex_i > r $

暴力树套树三维数点或者其他高妙做法。还可以加上尽量划分平均之类的小trick。可以做到$O(nlog^2n)$

#### 算法三

这是出题人的标算。这并不是复杂度最优的解法，但是思路比较有趣。

对区间分治，设当前的分治区间是$[l,r]$，中心是$mid$。

当我们固定一个左端点$i$时，就存在一个最小的$qr_i>=mid$，使得$[l,mid]$中的数可以被羁绊。当且仅当$[l,mid]$本身符合要求时等号成立。

同理一个右端点$i$，存在最大的$ql_i<=mid+1$，使得$[mid + 1, r]$中的数可以被羁绊。

枚举一个左端点$i$，我们要找的就是一个最大的右端点$j$，使得$qr_i <= j <= r, ql_j >= i$，
离线下来之后非常好处理。

复杂度$O(nlog^2n)$

然而当场通过的所有代码中没有一份用的是这个算法（打脸）

#### 算法四

用下面的算法可以做到$O(nlogn)$的复杂度。

枚举右端点$r$。然后我们只考虑$nexi>r$的数。显然最优的左端点是1或这样的$i+1$

如果$nexi > r$，那么区间$[i + 1, r]$符合条件的充要条件是：$\forall i < j <= r$，如果$nexj>r$，那么$prej>i$

只需维护：区间+1，区间-1，查询值为0的最小位置。线段树操作一番即可。

### Data Maker

这题的数据并不是很好造啊……写过对拍的同学会发现，在随机的大规模数据下，绝大多数数据答案都是$2$或者$n$。

我的dmk大致是每个数一定概率在$[1,k]$内随机，一定概率在$[2k-c,3k]$内随机，再随机若干个数变为+inf。然后通过调整参数得到了10组数据。

# K-stone

1.
$f_{i,j}$表示将区间$[i,j]$合并的代价，可得$f_{i,j}=min(f_{i,k}+f_{k+1,j}+sum_{i,j}) (i\le k<j)$
$sum_{i,j}=(\sum_{i}^{j} a_k^K)$
又由四边形不等式可将其优化到$O(n^2)$
具体为：
设$r_{i,j}$表示$f_{i,j}$在$k=r_{i,j}$时转移最优
由$sum_{i,j}+sum_{i+1,j+1}\le sum_{i,j+1}+sum_{i+1,j}$
可得$r_{i,j-1}\le r_{i,j}\le r_{i+1,j}$(四边形不等式)

2.
现在题目转化为将区间$[1,n]$分为$m$个区间，区间$[l,r]$的贡献为$f_{l,r}$,求 所有$m$个区间的贡献总和 的最小值
设$dp_{i,j}$表示前$i$个石子堆分成$j$个区间的最小值
易列出$dp$转移：
$dp_{i,j}=min(dp_{k,j-1}+f_{k+1,i})(1\le k<i)$
但显然复杂度为$O(n^2m)$过不了
那设$g_{i}$为把区间$[1,n]$分成$i$个区间的最小值，即$g_{i}=dp_{n,i}$
我们可以发现点$(1,g_{1}),(2,g_{2}),(3,g_{3}).....(n,g_{n})$在二维坐标中为一下凸包(虽然并不会证233)
于是就可以通过$dp$凸优化将$dp$有关$m$的一维去掉，此时复杂度$O(n^2logn)$

3.
列出此时的dp转移方程
$dp_{i}=min(dp_{j}+f_{j+1,i}-x)(0\le j<i)$
$dp$表示取，$x$是二分的斜率，在这里是定值
现在又由决策单调性可将其优化成$O(nlogn)$
加上二分复杂度，询问复杂度为$O(nlogn^2)$

总复杂度为$O(n^2+nlogn^2)$
# L-order

签到题，按照题意模拟即可
