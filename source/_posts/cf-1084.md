---
title: cf-1084
date: 2018-12-23 07:12:54
categories: 比赛
tags:
- 题解 
mathjax: true
---
div2A/B 略
# div2-C/div1-A

记录fa 表示以a结尾的合法序列数量

记录fb 表示以b结尾的合法序列数量

假如当前字符为a，那么 fa += fb + 1;
假如当前字符为b，那么 fb = fa;


# div2-D/div1-B

最重要的观察：本质就是在找点权和减去边权和最大的路径，这样的路径必然会满足题目的条件

如果不满足，可以用反证法证明这条路径并非是最大的

然后我们可以用一个树DP来做

dp[u]表u节点的子树中以u开头的点权边权之差最大的路径

那么dp[u]可能会是某个dp[v] 转移过来，v是u的某个儿子

也有可能从两个dp[v] 转移过来，相当于是一条横跨u的路径，由两条u走向子树的路径结合而成

由于dfs的时候是一个一个儿子枚举过去的，所以可以记录u的前面儿子的最优值prev，与当前子树的最优值进行合并

合并完成后再用当前子树的最优值去更新prev

# div2-E/div1-C

首先是理解题目意思
给你两个数n,k($n \le 500000, k \le 10^9$), 还有两个长度为n的字符串s，t

s的字典序小于等于t，求[s,t]之间选出k个串，不同前缀的数目最大是多少，所有的串都只有ab两种字符构成

相当于你有很多种选择k个串的方法，每一种方法都对应了一个不同前缀的数量，求所有方法中最大的一个


如果我们先找好k个串，然后再数一数有多少前缀，这样的计算量必然是天文数字

逆向思维是这类计数问题的常用解题思路，即算每一种长度的前缀在最终答案中被算到了几次

假设先不考虑字典序

再进一步思考，假设长度为i的满足条件的不同前缀有x个，那么这x个前缀完全可以再延伸一个字符然后作为长度为i+1的满足条件的不同前缀

由于字符只有两种所以长度为i+1的不同前缀有 x * 2种，但是我们只能选择k个串，所以要和k取个min

然后我们考虑字典序问题，根据s，t两个字符串的第i+1位的情况我们可以分类讨论四种情况

1: s[i+1] = 'a', t[i+1] = 'b'
x = x * 2; 所有的x * 2种的前缀都是合法的，因为后面无论接入a还是b都满足字典序列

2: s[i+1] = 'a', t[i+1] = 'a'
x = x * 2 - 1; 除了t[1~i]这个字典序最大的串后面不能接b，其他都可以随意的接上a b

3: s[i+1] = 'b', t[i+1] = 'b'
x = x * 2 - 1; 除了s[1~i]这个字典序最小的串后面不能接a，其他都可以随意的接上a b

4: s[i+1] = 'b', t[i+1] = 'a'
x = x * 2 - 2; 同上推理

所以只需要统计每种长度的前缀的数量和k取min相加就是答案了


