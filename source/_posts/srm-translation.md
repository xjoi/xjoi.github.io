---
title: srm-翻译
date: 2018-08-30 17:33:15
categories: topcoder
tags: noip普及
mathjax: true
---

# srm-728-div1-T1-Halving

## 题意

>你有一些木棍，现在你想让这些木棍都变成同样的长度
>你可以进行如下的操作
>选择一根长度为L>=2的木棍
>如果L为偶数，将木棍一分为2，变成两根L/2的木棍
>否则，分成一根为(L+1) / 2, 另一根为(L-1) / 2;
>在分成的两根中选择其中一根，扔掉另外一根
>可以证明的是任何集合的木棍都能最终变成一样长度的木棍
>现在问你最少需要几步可以完成任务
>$2<=n<=50, 1<=a_i<=10^9$

## 样例

```
{11, 4}
Returns: 3

最优方案是
选择长度为 11的木棍, 分成 5 and 6 ,保留5
选择长度为4的木棍,分成两个长度为2的，保留一个2
选择长度为5的, 分成2和3，保留2
现在得到了 两个2


{1, 2, 3, 4, 5, 6, 7}
Returns: 10
```

# srm-728-div2-T3-IncreasingSequencesEasy

## 题意

>给你一个有向图，每个点都只有一个出度
>问你存在多少的有向图，可以从原图中选择一个三元组$a,b,c$，重标号成$b,c,a$之后得到
>$1<=n<=10$



## 样例

```
{2, 2, 0}//表示0->2,1->2,2->0这个有向图
Returns: 2

0 1 2 -> 1 2 0 
1 2 0 -> 2 0 1
可以得到两个 {1, 2, 1} 与 {1, 0, 0}两个新图


{0, 1, 2, 3}
Returns: 0

每个点都是自环，不管怎么改变标号，图还是原图

{4, 5, 3, 1, 1, 5}
Returns: 179
```

# srm-728-div2-T2-IncreasingSequencesEasy

## 题意

>给你两个长度为n的数组L[],R[]
>求满足```L[i]<=A[i]<=R[i]```而且```A[0]<A[1]<...<A[n-1]```的序列的数量
>答案对998244353取模
>$1<=n<=300,1<=L[i]<=10^4,L[i]<=R[i]<=10^4$

## 样例

```
    
{1, 3, 1, 4}
{6, 5, 4, 6}
Returns: 4
There are 4 strictly increasing sequences satisfying the conditions: {1, 3, 4, 5}, {1, 3, 4, 6}, {2, 3, 4, 5} and {2, 3, 4, 6}.
1)

{10, 20}
{20, 30}
Returns: 120
```

# srm-729-div2-T2-SoManyRectangles


## 题意

>有n个矩形，问你最大重叠的次数
>边或者点的重叠不算
>$1<=n<=50$

## 样例

```
    
{0, 0, 0, 0, 0} // x1[]
{0, 0, 0, 0, 0} // y1[]
{1, 1, 1, 1, 1} // x2[]
{1, 1, 1, 1, 1} // y2[]

(x1[i], y1[i])  (x2[i], y2[i]) 表示一个矩形的左下角和右上角
Returns: 5

```

# srm-729-div2-T3-RareItems

## 题意

>给你一个数组表示每种物品的出现个数
>现在根据每种物品的比例随机购买每种物品
>期望购买几次能将每种物品都买到手
>$1<=n<=20$

## 样例

```
{2,2}
Returns: 3.0
```

# srm-729-div1-T1-MagicNumberThree

## 题意
>给你一个长度为50的数字串，问你有多少个子序列构成的数字可以被3整除
>答案对1e9+7取模

## 样例
    
```
"132"
Returns: 3

"00"
Returns: 3
```


# srm-730-div2-T2-ExpectedMinimumPowerDiv2

## 题意

>给你两个整数$n,x$, $1<=n<=50$
>假如要选择x个整数，每个整数都在1-n之间，
>现在在所有的这些选择中，我们选取x个数都不同的选择
>假设选择中最小的数为$S$,求$2^S$的期望
>也就是说每一种x个数不同的选择都会有一个$S_i$,求
>$2^{S_i}$的平均值，也就是期望

## 样例

```
    
4
4
Returns: 2.0
只能选择1 2 3 4
最小的数是1，所以答案是2^1=2
{1,2,3,4}其实有4!的排列，但是我们要算的是平均值，乘以排列数再除以排列数就相互抵消了

    
3
2
Returns: 2.6666666666666665
有三种选择 {1,2} or {1,3} or {2,3}. 
S值分别为1 1 2
2^S的期望为 (2^1 + 2^1 + 2^2) / 3 = 8 / 3 = 2.6666666
```

# srm-730-div2-T3-StonesOnATreeDiv2

## 题意

>给你一棵树，每个点有点权
>现在你可以在一些点上放石头，也可以拿掉某些点上的石头
>一个点可以放石头当且仅当这个点的所有儿子都放上了石头
>根节点放上石头任务完成
>求在整个过程中放着石头的节点的点权之和的最大值的最小值
>n<=1000

## 样例

```
{0,1,2,3} //分别表示1的父亲 2的父亲 3的父亲 4的父亲
{1,2,2,4,4}//每个点的点权值
Returns: 8
五个节点构成了一条链
在节点4上放一个石头 (权值和 = 4).
在节点3上放一个石头 (权值和 = 8).
移除节点4上的石头   (权值和 = 4).
在节点2上放一个石头 (权值和 = 6).
在节点1上放一个石头 (权值和 = 8).
移除节点2上的石头   (权值和 = 6)
在节点0(根节点)上放一个石头 (权值和 = 7)
整个过程中最大的权值和为8，不存在比最大值比8小的方案了
```

# srm-731-div2-T3-JustBrackets

## 题意

>给你一个合法的括号序列，每次你可以删除一个"()"
>你可以删除0个或者多个"()"
>求操作之后字典序最小的序列
>字符串长度<=100

## 样例

```
    
"()"
Returns: "()"

解释:要保证非空


"()()"
Returns: "()"


"(())"
Returns: "(())"


"(()(()))"
Returns: "((()))"
```

# srm-731-div1-T1-TreesAndBractkets

## 题意

>给你一个合法的括号序列s1，每次你可以删除一个"()"
>你可以删除0个或者多个"()"
>求能否删成另一个括号序列s2

## 样例

```
    
"()"
"()"
Returns: "Possible"

    
"(()()())"
"((()))"
Returns: "Impossible"

    
"((())((())())())"
"(()(())())"
Returns: "Possible"
```

# srm-733-div2-T2-BuildingSpanningTreesDiv2

## 题意

>有一副n个点的完全图G（每两个点之间都有边，一共有 n*(n-1)/2条边)
>告诉你一个边的集合E,里面有n-3条边
>G的生成树是选取G里面的n-1条边连接G中所有的点
>请问有多少的生成树会包括E，返回答案对987654323取模
>$4 <= n <= 1000$
>假设$x[i]->y[i]$表示E里面的一条边
>$x[i] < y[i]$ 

## 样例

```
    
n=4
x={1}
x={2}
Returns: 8

解释
8个生成树如下会包括边(1, 2):
{(1, 2), (1, 3), (1, 4)}
{(1, 2), (1, 3), (2, 4)}
{(1, 2), (1, 3), (3, 4)}
{(1, 2), (2, 3), (2, 4)}
{(1, 2), (1, 4), (2, 3)}
{(1, 2), (1, 4), (3, 4)}
{(1, 2), (2, 3), (3, 4)}
{(1, 2), (2, 4), (3, 4)}

    
n=6
x={1,1,2}
y={2,3,3}
Returns: 0

解释
n-3条边之间形成了环，无解

    
5
{1,2}
{4,5}
Returns: 20

```


# srm-733-div2-T3-HamiltonianPathsInGraph

## 题意
>有一个有向图,恰好有n*(n-1)/2条边，对于每一个(i，j)要么有一条
>i->j的边，要么有一条j->i的边,但不会同时存在这两条边
>给你这个图的邻接矩阵a，a[i][j]='+'表示i->j有边，'-'表示没有
>a[i][i]='.'表示这个图没有自环
>图的汉密尔顿路径是长度为n包含每个点恰好一次的路径
>实际上对于上面这种特性的图，一定存在至少一条汉密尔顿路径
>输出任意一条汉密尔顿路径

## 样例

```
{".+",
 "-."}
Returns: {0, 1 }

有唯一一条汉密尔顿路径0->1

{".--+",
 "+.+-",
 "+-.-",
 "-++."}
Returns: {3, 1, 2, 0 }
下面都是答案
{0, 3, 1, 2}
{1, 0, 3, 2}
{1, 2, 0, 3}
{2, 0, 3, 1}
{3, 1, 2, 0}

```


# srm-734-div2-T2-TheSquarecityDiv2

## 题意

>给你一个n*n的数字网格,每个格子表示一个房间,每个格子里面的数字表示房间的温度
>每个房间的温度都是不同的
>每个房间一开始都有一个人
>从(x1,y1)移动到(x2,y2)需要花费|x1-x2|+|y1-y2|的时间
>一个人每次移动的时间不得超过r
>现在所有人都开始重复如下操作:
>每个人都去寻找最近的比自己房间温度高的房间,直到距离r以内不存在温度更高的房间为止
>求最终有多少个房间里面有人 以及 人数最多的房间有多少人
>$1<=n<=20$

## 样例

```
r = 1

{
    9, 1, 6, 
    5, 3, 2, 
    7, 4, 8
}

ans = {4, 4}


温度为1与5的房间的人都走到了温度9的房间
3先走到5再走到9
2和4房间的最终都会到8
...

```

# srm-734-div2-T3-TheRectangularCityDiv2

## 题意

>给你一个n*m的网格，里面有空地和障碍,
>请问有多少种走法可以从边界的某个空地出发走遍每一个空地恰好一次，
>最后从某个边界的空地走出去
>$n\times m<=20$

## 样例

```
{
    "....", 
    ".##.", 
    "...."
}
Returns: 20



    
{
    "....", 
    ".###", 
    "...."
}
Returns: 2


{
    "....", 
    "####", 
    "...."
}
Returns: 0
```


# srm-734-div1-T1-TheRoundCityDiv1

## 题意

>给你一个半径为r，圆心在0 0位置的圆
>求从圆心处能看到多少个圆内的整点
>比如0 0 可以看到1 1，但是看不到2 2，因为2 2被1 1 挡住了
>$ 1 <= r <= 1e6 $


## 样例

```
2
Returns: 8
一共有12个点: (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0),  
最后四个点看不到
```

# srm-735-div2-T2-TeleportationMaze

## 题意

>给你一个网格迷宫，求从起点走到终点的最短路
>有两种走法
> - 走到上下左右某个相邻的空地，代价是1
> - 飞到上下左右离子集最近的空地，代价是2，可以跨越障碍
>网格大小<=50
## 样例

```
0 0 -> 3 3 
.##.
.###
.###
....

answer: 4

从0 0直接飞到0 3,再从0 3直接飞到3 3

0 1 -> 1 0
#.
.#

answer:-1 （无解）


0 0 -> 6 1
......
#####.
#.###.
#####.
#.###.
#####.
#.....

answer: 5
```


# srm_735_div2_T3_MajoritySubarray

## 题意
>给你一个数组，长度为100000, 每个元素都在0-49之间
>求多少子区间存在一个众数的数量大于区间长度的一半
>众数：出现最多的数

## 样例

```
0 0 1 2 0

answer： 8
一共是如下8个子区间

{0} {0} {1} {2} {0}
{0,0}:0的出现次数超过一半 
{0,0,1}：0的出现次数超过一半
{0,0,1,2,0}
```


# 736-div2-T2-Reroll

## 题意
>给你n个数,表示n个骰子向上的面的数字
>再给你一个数target(n<=target<=6*n)
>你可以选取这n个骰子中的若干个骰子重新扔
>最少需要选择几个骰子重新扔能使得所有朝上的数的和为target
>$1<=n<=20$

## 样例

```
42 
{1,3,5,3,6,4,2}

answer: 6

10
{4,2,4,5}

answer: 2
```

# 736-div2-T3-MazeWithKeys

## 题意
>你正在设计一个网格地图游戏，网格满足如下条件
>1：恰好有一个出口
>2：可能有一些门，门的标号为大写字母A-Z，每种门最多只有一个
>3：可能有一些钥匙，钥匙的标号为小写字母a-z，每种钥匙只能打开对应的大写字母的门
>4：可能有一些空地，空地的标号为小数点
>5：可能有一些障碍，障碍不能经过
>对于一个地图，你想要知道有多少的空地可以到达出口，为了使游戏显得不那么简单，你想要知道到达出口至少开一扇门的的空地有多少个
>n,m<=50
>'.' 代表空地
>'#' 代表障碍
>'*'代表出口


## 样例

```
6 7
...#.A.
.#B#.#.
.#.#.#.
.#.#.#.
.#b#.#.
a#...#*

输出:10


3 5 
a#a#*
#..#.
a..A.
输出:4
```
