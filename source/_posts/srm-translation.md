---
title: srm-翻译
date: 2018-08-30 17:33:15
categories: topcoder
tags: noip普及
mathjax: true
---

# srm-729-div2-T2-SoManyRectangles

## 题意

>有n个矩形，问你最大重叠的次数
>边或者点的重叠不算
>$1<=n<=50$

## 样例

```
    
{0, 0, 0, 0, 0} // x1[]
{0, 0, 0, 0, 0} // y1[]
{1, 1, 1, 1, 1} // x2[]
{1, 1, 1, 1, 1} // y2[]

(x1[i], y1[i])  (x2[i], y2[i]) 表示一个矩形的左下角和右上角
Returns: 5

```

# srm-730-div2-T2-ExpectedMinimumPowerDiv2

## 题意

>给你两个整数$n,x$, $1<=n<=50$
>假如要选择x个整数，每个整数都在1-n之间，
>现在在所有的这些选择中，我们选取x个数都不同的选择
>假设选择中最小的数为$S$,求$2^S$的期望
>也就是说每一种x个数不同的选择都会有一个$S_i$,求
>$2^{S_i}$的平均值，也就是期望

## 样例

```
    
4
4
Returns: 2.0
只能选择1 2 3 4
最小的数是1，所以答案是2^1=2
{1,2,3,4}其实有4!的排列，但是我们要算的是平均值，乘以排列数再除以排列数就相互抵消了

    
3
2
Returns: 2.6666666666666665
有三种选择 {1,2} or {1,3} or {2,3}. 
S值分别为1 1 2
2^S的期望为 (2^1 + 2^1 + 2^2) / 3 = 8 / 3 = 2.6666666
```

# srm-730-div2-T3-StonesOnATreeDiv2

## 题意

>给你一棵树，每个点有点权
>现在你可以在一些点上放石头，也可以拿掉某些点上的石头
>一个点可以放石头当且仅当这个点的所有儿子都放上了石头
>根节点放上石头任务完成
>求在整个过程中放着石头的节点的点权之和的最大值的最小值
>n<=1000

## 样例

```
{0,1,2,3} //分别表示1的父亲 2的父亲 3的父亲 4的父亲
{1,2,2,4,4}//每个点的点权值
Returns: 8
五个节点构成了一条链
在节点4上放一个石头 (权值和 = 4).
在节点3上放一个石头 (权值和 = 8).
移除节点4上的石头   (权值和 = 4).
在节点2上放一个石头 (权值和 = 6).
在节点1上放一个石头 (权值和 = 8).
移除节点2上的石头   (权值和 = 6)
在节点0(根节点)上放一个石头 (权值和 = 7)
整个过程中最大的权值和为8，不存在比最大值比8小的方案了
```

# srm-731-div2-T3-JustBrackets

## 题意

>给你一个合法的括号序列，每次你可以删除一个"()"
>你可以删除0个或者多个"()"
>求操作之后字典序最小的序列
>字符串长度<=100

## 样例

```
    
"()"
Returns: "()"

解释:要保证非空


"()()"
Returns: "()"


"(())"
Returns: "(())"


"(()(()))"
Returns: "((()))"
```

# srm-731-div1-T1-TreesAndBractkets

## 题意

>给你一个合法的括号序列s1，每次你可以删除一个"()"
>你可以删除0个或者多个"()"
>求能否删成另一个括号序列s2

## 样例

```
    
"()"
"()"
Returns: "Possible"

    
"(()()())"
"((()))"
Returns: "Impossible"

    
"((())((())())())"
"(()(())())"
Returns: "Possible"
```

# srm-733-div2-T2-BuildingSpanningTreesDiv2

## 题意

>有一副n个点的完全图G（每两个点之间都有边，一共有 n*(n-1)/2条边)
>告诉你一个边的集合E,里面有n-3条边
>G的生成树是选取G里面的n-1条边连接G中所有的点
>请问有多少的生成树会包括E，返回答案对987654323取模
>$4 <= n <= 1000$
>假设$x[i]->y[i]$表示E里面的一条边
>$x[i] < y[i]$ 

## 样例

```
    
n=4
x={1}
x={2}
Returns: 8

解释
8个生成树如下会包括边(1, 2):
{(1, 2), (1, 3), (1, 4)}
{(1, 2), (1, 3), (2, 4)}
{(1, 2), (1, 3), (3, 4)}
{(1, 2), (2, 3), (2, 4)}
{(1, 2), (1, 4), (2, 3)}
{(1, 2), (1, 4), (3, 4)}
{(1, 2), (2, 3), (3, 4)}
{(1, 2), (2, 4), (3, 4)}

    
n=6
x={1,1,2}
y={2,3,3}
Returns: 0

解释
n-3条边之间形成了环，无解

    
5
{1,2}
{4,5}
Returns: 20

```


# srm-733-div2-T3-HamiltonianPathsInGraph

## 题意
>有一个有向图,恰好有n*(n-1)/2条边，对于每一个(i，j)要么有一条
>i->j的边，要么有一条j->i的边,但不会同时存在这两条边
>给你这个图的邻接矩阵a，a[i][j]='+'表示i->j有边，'-'表示没有
>a[i][i]='.'表示这个图没有自环
>图的汉密尔顿路径是长度为n包含每个点恰好一次的路径
>实际上对于上面这种特性的图，一定存在至少一条汉密尔顿路径
>输出任意一条汉密尔顿路径

## 样例

```
{".+",
 "-."}
Returns: {0, 1 }

有唯一一条汉密尔顿路径0->1

{".--+",
 "+.+-",
 "+-.-",
 "-++."}
Returns: {3, 1, 2, 0 }
下面都是答案
{0, 3, 1, 2}
{1, 0, 3, 2}
{1, 2, 0, 3}
{2, 0, 3, 1}
{3, 1, 2, 0}

```


# srm-734-div2-T2-TheSquarecityDiv2

## 题意

>给你一个n*n的数字网格,每个格子表示一个房间,每个格子里面的数字表示房间的温度
>每个房间的温度都是不同的
>每个房间一开始都有一个人
>从(x1,y1)移动到(x2,y2)需要花费|x1-x2|+|y1-y2|的时间
>一个人每次移动的时间不得超过r
>现在所有人都开始重复如下操作:
>每个人都去寻找最近的比自己房间温度高的房间,直到距离r以内不存在温度更高的房间为止
>求最终有多少个房间里面有人 以及 人数最多的房间有多少人
>$1<=n<=20$

## 样例

```
r = 1

{
    9, 1, 6, 
    5, 3, 2, 
    7, 4, 8
}

ans = {4, 4}


温度为1与5的房间的人都走到了温度9的房间
3先走到5再走到9
2和4房间的最终都会到8
...

```

# srm-734-div2-T3-TheRectangularCityDiv2

## 题意

>给你一个n*m的网格，里面有空地和障碍,
>请问有多少种走法可以从边界的某个空地出发走遍每一个空地恰好一次，
>最后从某个边界的空地走出去
>$n\times m<=20$

## 样例

```
{
    "....", 
    ".##.", 
    "...."
}
Returns: 20



    
{
    "....", 
    ".###", 
    "...."
}
Returns: 2


{
    "....", 
    "####", 
    "...."
}
Returns: 0
```


# srm-734-div1-T1-TheRoundCityDiv1

## 题意

>给你一个半径为r，圆心在0 0位置的圆
>求从圆心处能看到多少个圆内的整点
>比如0 0 可以看到1 1，但是看不到2 2，因为2 2被1 1 挡住了
>$ 1 <= r <= 1e6 $


## 样例

```
2
Returns: 8
一共有12个点: (0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1), (0, 2), (0, -2), (2, 0), (-2, 0),  
最后四个点看不到
```

# srm-735-div2-T2-TeleportationMaze

## 题意

>给你一个网格迷宫，求从起点走到终点的最短路
>有两种走法
> - 走到上下左右某个相邻的空地，代价是1
> - 飞到上下左右离子集最近的空地，代价是2，可以跨越障碍
>网格大小<=50
## 样例

```
0 0 -> 3 3 
.##.
.###
.###
....

answer: 4

从0 0直接飞到0 3,再从0 3直接飞到3 3

0 1 -> 1 0
#.
.#

answer:-1 （无解）


0 0 -> 6 1
......
#####.
#.###.
#####.
#.###.
#####.
#.....

answer: 5
```


# srm_735_div2_T3_MajoritySubarray

## 题意
>给你一个数组，长度为100000, 每个元素都在0-49之间
>求多少子区间存在一个众数的数量大于区间长度的一半
>众数：出现最多的数

## 样例

```
0 0 1 2 0

answer： 8
一共是如下8个子区间

{0} {0} {1} {2} {0}
{0,0}:0的出现次数超过一半 
{0,0,1}：0的出现次数超过一半
{0,0,1,2,0}
```


# 736-div2-T2-Reroll

## 题意
>给你n个数,表示n个骰子向上的面的数字
>再给你一个数target(n<=target<=6*n)
>你可以选取这n个骰子中的若干个骰子重新扔
>最少需要选择几个骰子重新扔能使得所有朝上的数的和为target
>$1<=n<=20$

## 样例

```
42 
{1,3,5,3,6,4,2}

answer: 6

10
{4,2,4,5}

answer: 2
```

# 736-div2-T3-MazeWithKeys

## 题意
>你正在设计一个网格地图游戏，网格满足如下条件
>1：恰好有一个出口
>2：可能有一些门，门的标号为大写字母A-Z，每种门最多只有一个
>3：可能有一些钥匙，钥匙的标号为小写字母a-z，每种钥匙只能打开对应的大写字母的门
>4：可能有一些空地，空地的标号为小数点
>5：可能有一些障碍，障碍不能经过
>对于一个地图，你想要知道有多少的空地可以到达出口，为了使游戏显得不那么简单，你想要知道到达出口至少开一扇门的的空地有多少个
>n,m<=50
>'.' 代表空地
>'#' 代表障碍
>'*'代表出口


## 样例

```
6 7
...#.A.
.#B#.#.
.#.#.#.
.#.#.#.
.#b#.#.
a#...#*

输出:10


3 5 
a#a#*
#..#.
a..A.
输出:4
```
