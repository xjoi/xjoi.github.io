<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>cf-260</title>
      <link href="/cf-260/"/>
      <url>/cf-260/</url>
      <content type="html"><![CDATA[<h2 id="A-Adding-Digits"><a href="#A-Adding-Digits" class="headerlink" title="A Adding Digits"></a>A Adding Digits</h2><h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><blockquote><p>给出数字a和b，每次在a后面添加一位数字，重复n次，使得每次产生的数字a都能够被b整除</p></blockquote><h3 id="Data-Limit：1-lt-a-b-n-lt-10-5-Time-Limit-2s"><a href="#Data-Limit：1-lt-a-b-n-lt-10-5-Time-Limit-2s" class="headerlink" title="Data Limit：1 &lt;= a,b,n &lt;= 10^5  Time Limit: 2s"></a>Data Limit：1 &lt;= a,b,n &lt;= 10^5  Time Limit: 2s</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>因为一旦添加某一位后a不能被b整除，整个操作就不合法，因此可行方案的第一次添加就必须使a被b整除，剩余的n-1次操作只需添加0即可<br>如果在第一次添加时找不到可行方案则输出-1</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="cpp">    for (int i=0;i&lt;=9;++i){        int x=a*10+i;        if (x%b==0){            printf(&quot;%d&quot;,x);            for (int i=1;i&lt;n;++i) printf(&quot;0&quot;);            return 0;        }    }    printf(&quot;-1&quot;);</code></pre><hr><h2 id="B-Ancient-Prophesy"><a href="#B-Ancient-Prophesy" class="headerlink" title="B Ancient Prophesy"></a>B Ancient Prophesy</h2><h3 id="Problem-description-1"><a href="#Problem-description-1" class="headerlink" title="Problem description"></a>Problem description</h3><blockquote><p>给出由数字和‘-’组成的字符串，求在该字符串中出现次数最多的日期。<br>日期格式为dd-mm-yyyy，不足的用0补齐，需保证年份在2013-2015之间</p></blockquote><h3 id="Data-Limit：0-lt-s-lt-10-5-Time-Limit-1s"><a href="#Data-Limit：0-lt-s-lt-10-5-Time-Limit-1s" class="headerlink" title="Data Limit：0 &lt; |s| &lt;= 10^5  Time Limit: 1s"></a>Data Limit：0 &lt; |s| &lt;= 10^5  Time Limit: 1s</h3><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>暴力枚举每一位为起点，检查该段是否合法即可</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="cpp">    scanf(&quot;%s&quot;,s);    int len=strlen(s);    for (int i=0;i+9&lt;len;++i){        bool f=1;        for (int j=0;j&lt;=9;++j){            //printf(&quot;%c %d %d\n&quot;,s[i+j],i,j);            if (j==2||j==5){                if (s[i+j]!=&#39;-&#39;){f=0; break;}            }            else if (s[i+j]&lt;&#39;0&#39;||s[i+j]&gt;&#39;9&#39;){f=0; break;}        }        //printf(&quot;  orz\n&quot;);        if (!f) continue;        int d=(s[i]-&#39;0&#39;)*10+(s[i+1]-&#39;0&#39;);        int m=(s[i+3]-&#39;0&#39;)*10+(s[i+4]-&#39;0&#39;),y=0;        for (int j=6;j&lt;=9;++j) y*=10, y+=s[i+j]-&#39;0&#39;;    //    printf(&quot;%d %d %d\n&quot;,d,m,y);        if (m&gt;12||m&lt;1||y&gt;2015||y&lt;2013||d&gt;month[m]) continue;        a[y-2013][m][d]++;    }    int d=1,m=1,y=0;    for (int i=0;i&lt;=2;++i)        for (int j=1;j&lt;=12;++j)            for (int k=1;k&lt;=month[j];++k){                if (a[i][j][k]&gt;a[y][m][d]) y=i,m=j,d=k;            }    if (d&gt;=10) printf(&quot;%d-&quot;,d); else printf(&quot;0%d-&quot;,d);    if (m&gt;=10) printf(&quot;%d-&quot;,m); else printf(&quot;0%d-&quot;,m);    printf(&quot;%d\n&quot;,y+2013);</code></pre><hr><h2 id="C-Balls-and-Boxes"><a href="#C-Balls-and-Boxes" class="headerlink" title="C Balls and Boxes"></a>C Balls and Boxes</h2><h3 id="Problem-description-2"><a href="#Problem-description-2" class="headerlink" title="Problem description"></a>Problem description</h3><blockquote><p>有n个箱子，每个箱子里都有一定数量的球。<br>现在取出某个箱子里的所有球，从后面一个位置开始，依次在后面的箱子里放入一个球，放完为止。若到第n个还没放完，返回第一个继续放。<br>已知放完后所有箱子的状态和结束位置，求初始状态</p></blockquote><h3 id="Data-Limit：n-lt-10-5-a-i-lt-10-9-a-i-0-Time-Limit-1s"><a href="#Data-Limit：n-lt-10-5-a-i-lt-10-9-a-i-0-Time-Limit-1s" class="headerlink" title="Data Limit：n &lt;= 10^5, a[i] &lt;= 10^9, a[i] != 0  Time Limit: 1s"></a>Data Limit：n &lt;= 10^5, a[i] &lt;= 10^9, a[i] != 0  Time Limit: 1s</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>暴力做法是一个一个往前减，直到访问到的位置为0为止。但这样会超时。<br>显然的，最终状态里球数量最少的位置即为初始位置，记为loc。终点记为x，则可以分类讨论：<br>1.当loc==x，刚好经过每个位置a[loc]次<br>2.当loc&gt;x，说明经过了所有位置a[loc]次，另外，loc+1到n位置1次，1到x位置1次<br>3.当loc&lt;x，说明经过所有位置a[loc]次，另外，loc+1到x位置1次</p></blockquote><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="cpp">    long long tmp=1e18,loc;    for (int i=1;i&lt;=n;++i) scanf(&quot;%I64d&quot;,&amp;a[i]);    for (int i=x;i&gt;=1;--i) if (a[i]&lt;tmp) tmp=a[i],loc=i;    for (int i=n;i&gt;x;--i) if (a[i]&lt;tmp) tmp=a[i],loc=i;    long long sum=0;    if (loc==x){        for (int i=1;i&lt;=n;++i) a[i]-=tmp,sum+=tmp;    }else if (loc&gt;x){        for (int i=loc+1;i&lt;=n;++i) a[i]--,sum++;        for (int i=1;i&lt;=x;++i) a[i]--,sum++;        for (int i=1;i&lt;=n;++i) a[i]-=tmp,sum+=tmp;    }else{        for (int i=loc+1;i&lt;=x;++i) a[i]--,sum++;        for (int i=1;i&lt;=n;++i) a[i]-=tmp,sum+=tmp;    }    a[loc]+=sum;</code></pre><hr><h2 id="D-Black-and-White-Tree"><a href="#D-Black-and-White-Tree" class="headerlink" title="D Black and White Tree"></a>D Black and White Tree</h2><h3 id="Problem-description-3"><a href="#Problem-description-3" class="headerlink" title="Problem description"></a>Problem description</h3><blockquote><p>有一颗结点为黑白两色的树，每条边都有权值且连接颜色不同的两个点，每个点的权值等于连接该点的边的权值总和<br>现在给出n个点的颜色和权值，求边的连接情况</p></blockquote><h3 id="Data-Limit：2-lt-n-lt-10-5-Time-Limit-1s"><a href="#Data-Limit：2-lt-n-lt-10-5-Time-Limit-1s" class="headerlink" title="Data Limit：2 &lt;= n &lt;= 10^5  Time Limit: 1s"></a>Data Limit：2 &lt;= n &lt;= 10^5  Time Limit: 1s</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>因为每条边都连接颜色不同的点，所以黑点的权值和等于白点的权值和。<br>对于一个点，它的权值是周围所有边的权值之和。因此边权&lt;=min(两点的权值)，即决定边权的是权值较小的点。<br>因此从权值较小的点逐个连接即可</p></blockquote><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre><code class="cpp">struct xint{    int sum,no;    xint(){}    xint(int _sum,int _no):sum(_sum),no(_no){}};struct cmp{    bool operator()(xint &amp;a,xint &amp;b){        return a.sum&gt;b.sum;    }};priority_queue&lt; xint,vector&lt;xint&gt;,cmp &gt; q_black;priority_queue&lt; xint,vector&lt;xint&gt;,cmp &gt; q_white;    for (int i=1;i&lt;=n;++i){        int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        xint tmp(y,i);        if (x) q_black.push(tmp),cntb++; else q_white.push(tmp),cntw++;    }    for (int i=1;i&lt;n;++i){        xint a=q_black.top(),b=q_white.top();        q_black.pop(),cntb--, q_white.pop(),cntw--;        u[i]=a.no,v[i]=b.no;        w[i]=min(a.sum,b.sum);        a.sum-=w[i], b.sum-=w[i];        if (a.sum==0&amp;&amp;b.sum==0){            if (cntw==0) q_white.push(b),cntw++;            else q_black.push(a),cntb++;        }//注意两个都为0的情况        if (a.sum&gt;0) q_black.push(a),cntb++;        if (b.sum&gt;0) q_white.push(b),cntw++;    }</code></pre><hr><h2 id="E-Dividing-Kingdom"><a href="#E-Dividing-Kingdom" class="headerlink" title="E Dividing Kingdom"></a>E Dividing Kingdom</h2><h3 id="Problem-description-4"><a href="#Problem-description-4" class="headerlink" title="Problem description"></a>Problem description</h3><blockquote><p>给定平面上n个点和9个数，求两条平行于x轴的直线和两条平行于y轴的直线，使得被直线分成的9个区域中，<br>点的数量和给定的9个数对应</p></blockquote><h3 id="Data-Limit：9-lt-n-lt-10-5-10-9-lt-xi-yi-lt-10-9-Time-Limit-2s"><a href="#Data-Limit：9-lt-n-lt-10-5-10-9-lt-xi-yi-lt-10-9-Time-Limit-2s" class="headerlink" title="Data Limit：9 &lt;= n &lt;= 10^5, -10^9 &lt;= xi,yi &lt;= 10^9  Time Limit: 2s"></a>Data Limit：9 &lt;= n &lt;= 10^5, -10^9 &lt;= xi,yi &lt;= 10^9  Time Limit: 2s</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>dfs枚举9个数在9个区域的排列，分别check<br>可用线段树维护纵坐标，每次check时在一定区间内二分横坐标，统计个数<br>因为保证点的坐标为整数，所以直线的坐标是点+0.5</p></blockquote><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><pre><code class="cpp">struct Point{    int x,y;    void read(){        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);    }    Point(){}    Point(int _x,int _y):x(_x),y(_y){}    bool operator &lt; (const Point &amp;a){        return x&lt;a.x||x==a.x&amp;&amp;y&lt;a.y;    }}p[100010];void build(int l,int r,int k){    tree[k].clear();    for (int i=l;i&lt;=r;++i) tree[k].push_back(p[i].y);    if (l==r) return;    int mid=(l+r)/2;    build(l,mid,k*2); build(mid+1,r,k*2+1);    sort(tree[k].begin(),tree[k].end());}int query(int l,int r,int k,int x,int y,int cnt){    if (x&lt;=l&amp;&amp;r&lt;=y){        int ll=0,rr=tree[k].size()-1;        if (tree[k][0]&gt;cnt||ll&gt;rr) return 0;        int ans=0;        while (ll&lt;=rr){            int mid=(ll+rr)/2;            if (tree[k][mid]&lt;=cnt) ll=mid+1,ans=mid; else rr=mid-1;        }    //    printf(&quot;%d\n&quot;,ans+1);        return ans+1;    }    int mid=(l+r)/2,ans=0;    if (x&lt;=mid) ans+=query(l,mid,k*2,x,y,cnt);    if (y&gt;mid) ans+=query(mid+1,r,k*2+1,x,y,cnt);    return ans;}bool check(int x1,int x2,int y1,int y2){    if (x1+1&gt;=n||x1+x2+1&gt;=n||y1+1&gt;=n||y1+y2+1&gt;=n) return 0;    if (x[x1]==x[x1+1]||x[x1+x2]==x[x1+x2+1]) return 0;    if (y[y1]==y[y1+1]||y[y1+y2]==y[y1+y2+1]) return 0;    int m=query(1,n,1,1,x1,y[y1]); if (m!=num[1]) return 0;    m=query(1,n,1,1,x1,y[y1+y2]); if (m!=num[1]+num[4]) return 0;    m=query(1,n,1,x1+1,x1+x2,y[y1]); /*printf(&quot;%d %d %d\n&quot;,x1+1,x2+x1,m);*/ if (m!=num[2]) return 0;    m=query(1,n,1,x1+1,x1+x2,y[y1+y2]); if (m!=num[2]+num[5]) return 0;    return 1;}void dfs(int s){    if (flag) return;    if (s==9){        int y1=num[1]+num[2]+num[3],y2=num[4]+num[5]+num[6];        int x1=num[1]+num[4]+num[7],x2=num[2]+num[5]+num[8];        if (check(x1,x2,y1,y2)){            double ansx1,ansx2,ansy1,ansy2;            printf(&quot;%.10f %.10f\n&quot;,x[x1]+0.5,x[x1+x2]+0.5);            printf(&quot;%.10f %.10f\n&quot;,y[y1]+0.5,y[y1+y2]+0.5);            flag=1;        }        return;    }    for (int i=1;i&lt;=9;++i)        if (!b[i]){            b[i]=1; num[s+1]=a[i];            dfs(s+1);            b[i]=0;        }}    for (int i=1;i&lt;=n;++i) p[i].read();    for (int i=1;i&lt;=n;++i) x[i]=p[i].x,y[i]=p[i].y;    for (int i=1;i&lt;=9;++i) scanf(&quot;%d&quot;,&amp;a[i]);    sort(p+1,p+1+n);    sort(x+1,x+1+n);    sort(y+1,y+1+n);    build(1,n,1);    flag=0; dfs(0);    if (!flag) printf(&quot;-1&quot;);</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>cf-1084</title>
      <link href="/cf-1084/"/>
      <url>/cf-1084/</url>
      <content type="html"><![CDATA[<p>div2A/B 略</p><h1 id="div2-C-div1-A"><a href="#div2-C-div1-A" class="headerlink" title="div2-C/div1-A"></a>div2-C/div1-A</h1><p>记录fa 表示以a结尾的合法序列数量</p><p>记录fb 表示以b结尾的合法序列数量</p><p>假如当前字符为a，那么 fa += fb + 1;<br>假如当前字符为b，那么 fb = fa;</p><h1 id="div2-D-div1-B"><a href="#div2-D-div1-B" class="headerlink" title="div2-D/div1-B"></a>div2-D/div1-B</h1><p>最重要的观察：本质就是在找点权和减去边权和最大的路径，这样的路径必然会满足题目的条件</p><p>如果不满足，可以用反证法证明这条路径并非是最大的</p><p>然后我们可以用一个树DP来做</p><p>dp[u]表u节点的子树中以u开头的点权边权之差最大的路径</p><p>那么dp[u]可能会是某个dp[v] 转移过来，v是u的某个儿子</p><p>也有可能从两个dp[v] 转移过来，相当于是一条横跨u的路径，由两条u走向子树的路径结合而成</p><p>由于dfs的时候是一个一个儿子枚举过去的，所以可以记录u的前面儿子的最优值prev，与当前子树的最优值进行合并</p><p>合并完成后再用当前子树的最优值去更新prev</p><h1 id="div2-E-div1-C"><a href="#div2-E-div1-C" class="headerlink" title="div2-E/div1-C"></a>div2-E/div1-C</h1><p>首先是理解题目意思<br>给你两个数n,k($n \le 500000, k \le 10^9$), 还有两个长度为n的字符串s，t</p><p>s的字典序小于等于t，求[s,t]之间选出k个串，不同前缀的数目最大是多少，所有的串都只有ab两种字符构成</p><p>相当于你有很多种选择k个串的方法，每一种方法都对应了一个不同前缀的数量，求所有方法中最大的一个</p><p>如果我们先找好k个串，然后再数一数有多少前缀，这样的计算量必然是天文数字</p><p>逆向思维是这类计数问题的常用解题思路，即算每一种长度的前缀在最终答案中被算到了几次</p><p>假设先不考虑字典序</p><p>再进一步思考，假设长度为i的满足条件的不同前缀有x个，那么这x个前缀完全可以再延伸一个字符然后作为长度为i+1的满足条件的不同前缀</p><p>由于字符只有两种所以长度为i+1的不同前缀有 x * 2种，但是我们只能选择k个串，所以要和k取个min</p><p>然后我们考虑字典序问题，根据s，t两个字符串的第i+1位的情况我们可以分类讨论四种情况</p><p>1: s[i+1] = ‘a’, t[i+1] = ‘b’<br>x = x <em> 2; 所有的x </em> 2种的前缀都是合法的，因为后面无论接入a还是b都满足字典序列</p><p>2: s[i+1] = ‘a’, t[i+1] = ‘a’<br>x = x * 2 - 1; 除了t[1~i]这个字典序最大的串后面不能接b，其他都可以随意的接上a b</p><p>3: s[i+1] = ‘b’, t[i+1] = ‘b’<br>x = x * 2 - 1; 除了s[1~i]这个字典序最小的串后面不能接a，其他都可以随意的接上a b</p><p>4: s[i+1] = ‘b’, t[i+1] = ‘a’<br>x = x * 2 - 2; 同上推理</p><p>所以只需要统计每种长度的前缀的数量和k取min相加就是答案了</p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何查询一名oi选手的综合实力</title>
      <link href="/oi-search/"/>
      <url>/oi-search/</url>
      <content type="html"><![CDATA[<h1 id="如何查询一名oi选手的综合实力"><a href="#如何查询一名oi选手的综合实力" class="headerlink" title="如何查询一名oi选手的综合实力"></a>如何查询一名oi选手的综合实力</h1><p>首先是NOI官网上的历史成绩搜索</p><p><a href="http://www.noi.cn/awardsearch.html" target="_blank" rel="noopener">http://www.noi.cn/awardsearch.html</a></p><p>其次，如果你知道这名选手在竞赛圈内的常用ID(比如叫做username)，可以访问</p><p>codeforces.com/profile/username</p><p>CF上常见的实力档位从上往下依次是是红名，橙名，紫名，蓝名，绿名，灰名</p><p>看这名选手的rating曲线的分布，可以大致判断选手的实力</p>]]></content>
      
      <categories>
          
          <category> 竞赛周边 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第一届校赛题解</title>
      <link href="/xjoi-school-contest-solution/"/>
      <url>/xjoi-school-contest-solution/</url>
      <content type="html"><![CDATA[<h1 id="A-easymath"><a href="#A-easymath" class="headerlink" title="A-easymath"></a>A-easymath</h1><p>找出所有x的约数然后看他们的最小公倍数是否是x即可</p><h1 id="B-permutation"><a href="#B-permutation" class="headerlink" title="B-permutation"></a>B-permutation</h1><p>听说赛场上有人直接打表找规律过了此题？太强了。</p><p>这题本着送温暖的目的，被找到规律了也没事。</p><p>讲讲科学些的做法：</p><p>首先，要清楚一点：排列和置换是可以一一对应的，而且如果假设有点 1…n ，将所有的边 $(i,p_i)$ 连接起来，那么一个排列就对应一个由若干个环构成的图。</p><p>假设我们要算的是所有排列的贡献和。</p><p>我们考虑算出每一个数字对于答案的贡献。假设当前数字存在于一个大小为 $t (t\leq n)$ 的环中，那么有 $\binom{n-1}{t-1}(t-1)!(n-t)!$ 种可能。而 $\binom{n-1}{t-1}(t-1)!(n-t)!=(n-1)!$ 。如果这个数有贡献，那么当且仅当 $t$ 是 $k$ 的因数。设 $x$ 为小于等于 $n$ 的 $k$ 的因数，那么 1…n 的任何一个数都对答案有 $(n-1)!x$ 的贡献。所以总贡献为 $n!x$ 。</p><p>由于题目要求的是期望，所以答案要除以 $n!$ ，于是答案就是 $x$ —— 小于等于 $n$ 的 $k$ 的因数个数。</p><p>于是题目中的模数其实并没什么用，只是个障眼法。题目中的 $n,k$ 数据范围可以开的更大，只开 1e9 的也只是个障眼法。</p><h1 id="C-glance"><a href="#C-glance" class="headerlink" title="C-glance"></a>C-glance</h1><p>直接for循环按照题意模拟即可</p><h1 id="D-sequence"><a href="#D-sequence" class="headerlink" title="D-sequence"></a>D-sequence</h1><p>我们考虑如何 $O(n)$ 求出一个序列的不同子序列种数。</p><p>令 $dp_i$ 表示前 $i$ 个数字组成的序列的不同子序列种数，则 $dp_{i+1}=2dp_i-dp_{last_{a_{i+1}}-1}$ 。其中 $last_{a_{i+1}}$表示上一次 $a_{i+1}$ 出现之前的 DP 值。</p><p>表示的意义是：第 $i$ 位在子序列中可以选择不选或者选，但是有 $dp_{last_{a_{i+1}}}$ 种情况重复了，要减掉。</p><p>时间复杂度 $O(nm)$ 。</p><p>考虑把 dp 转移采用矩阵的形式，不难写出对于每一种 $a_i$ 的转移矩阵。由于 $a_i$ 的取值只有 $4$ 种，构造矩阵，令前 $4$ 列分别为对应的数的 $dp_{last_{v}-1}$ 值，第 $5$ 列表示 DP 值，所以转移矩阵的长宽为 $L=5$ ，则我们可以用线段树维护区间转移矩阵乘积。为了支持修改，我们需要预处理矩阵的幂。</p><p>时间复杂度 $O(L^3 m \log n )$ 。</p><h1 id="E-game"><a href="#E-game" class="headerlink" title="E-game"></a>E-game</h1><p>先暴力找到总共的轮数z，得分总和为x+y</p><p>那么每轮的得分为</p><p>1 3 5 7 … 2z-1</p><p>那么我们需要判断这里面最少需要几个数加起来等于x</p><p>从小到大枚举答案cnt</p><p>我们我们取cnt个数，他们的和可以凑成的最小值是前面cnt个数，最大值是后面cnt个数，显然最小值和最大值的奇偶性是一样的，稍微再思考一下我们会发现，最小值+2，最小值+4，最小值+6…一直到最大值这些数我们都可以拼成</p><p>所以我们只需要判断x是否在最小值和最大值之间以及x的奇偶性与最小值是否一致即可</p><h1 id="F-candle"><a href="#F-candle" class="headerlink" title="F-candle"></a>F-candle</h1><p>由于总点数比较小，我们只需要大力状压枚举选择了那些叶子结点然后模拟题意</p><h1 id="G-string"><a href="#G-string" class="headerlink" title="G-string"></a>G-string</h1><p>考察KMP算法next数组的应用，没学过的去学学吧</p><h1 id="H-hex"><a href="#H-hex" class="headerlink" title="H-hex"></a>H-hex</h1><p>首先建图，将每个六边形看成一个点，发现三个六边形有一个公共顶点就给这三个点建边，整个图会形成若干个联通块，我们依次放置同一个联通块内每一个点的标记，我们发现每一个标记都可以到达联通块内的任意一个地方，于是第一个点有cnt种标记可以放，第二个点有cnt-1种标记可以放..</p><p>但是要注意最后联通在一起的三个点只有三种方案可以放</p><p>所以答案为<br>$cnt \times (cnt-1) \times … \times 3 $</p><h1 id="I-stars"><a href="#I-stars" class="headerlink" title="I-stars"></a>I-stars</h1><p>模拟题</p><h1 id="J-memory"><a href="#J-memory" class="headerlink" title="J-memory"></a>J-memory</h1><h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>我会$O(n^4)$暴力！这种情况应用于没有人愿意验题时出题人的自救行为。</p><h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p>一个直观的想法是，如果一个数不能和其余的$n-1$个数羁绊，这个数不会出现在答案区间。</p><p>那么我们一开始保留整个区间。如果区间中所有的数都能被羁绊，直接更新答案。否则，找到一个不能被羁绊的数删除，划分为两个区间处理。</p><p>数据结构大师这时候就可以直接强上了。对于每个数记录前一个可以羁绊它的数$pre_i$和后一个可以羁绊它的数$nex_i$，只需要在当前区间中查找满足以下条件的数i：</p><p>$ l &lt;= i &lt;= r $，$ pre_i &lt; l $，$ nex_i &gt; r $</p><p>暴力树套树三维数点或者其他高妙做法。还可以加上尽量划分平均之类的小trick。可以做到$O(nlog^2n)$</p><h4 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h4><p>这是出题人的标算。这并不是复杂度最优的解法，但是思路比较有趣。</p><p>对区间分治，设当前的分治区间是$[l,r]$，中心是$mid$。</p><p>当我们固定一个左端点$i$时，就存在一个最小的$qr_i&gt;=mid$，使得$[l,mid]$中的数可以被羁绊。当且仅当$[l,mid]$本身符合要求时等号成立。</p><p>同理一个右端点$i$，存在最大的$ql_i&lt;=mid+1$，使得$[mid + 1, r]$中的数可以被羁绊。</p><p>枚举一个左端点$i$，我们要找的就是一个最大的右端点$j$，使得$qr_i &lt;= j &lt;= r, ql_j &gt;= i$，<br>离线下来之后非常好处理。</p><p>复杂度$O(nlog^2n)$</p><p>然而当场通过的所有代码中没有一份用的是这个算法（打脸）</p><h4 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h4><p>用下面的算法可以做到$O(nlogn)$的复杂度。</p><p>枚举右端点$r$。然后我们只考虑$nexi&gt;r$的数。显然最优的左端点是1或这样的$i+1$</p><p>如果$nexi &gt; r$，那么区间$[i + 1, r]$符合条件的充要条件是：$\forall i &lt; j &lt;= r$，如果$nexj&gt;r$，那么$prej&gt;i$</p><p>只需维护：区间+1，区间-1，查询值为0的最小位置。线段树操作一番即可。</p><h3 id="Data-Maker"><a href="#Data-Maker" class="headerlink" title="Data Maker"></a>Data Maker</h3><p>这题的数据并不是很好造啊……写过对拍的同学会发现，在随机的大规模数据下，绝大多数数据答案都是$2$或者$n$。</p><p>我的dmk大致是每个数一定概率在$[1,k]$内随机，一定概率在$[2k-c,3k]$内随机，再随机若干个数变为+inf。然后通过调整参数得到了10组数据。</p><h1 id="K-stone"><a href="#K-stone" class="headerlink" title="K-stone"></a>K-stone</h1><p>1.<br>$f_{i,j}$表示将区间$[i,j]$合并的代价，可得$f_{i,j}=min(f_{i,k}+f_{k+1,j}+sum_{i,j}) (i\le k&lt;j)$<br>$sum_{i,j}=(\sum_{i}^{j} a_k^K)$<br>又由四边形不等式可将其优化到$O(n^2)$<br>具体为：<br>设$r_{i,j}$表示$f_{i,j}$在$k=r_{i,j}$时转移最优<br>由$sum_{i,j}+sum_{i+1,j+1}\le sum_{i,j+1}+sum_{i+1,j}$<br>可得$r_{i,j-1}\le r_{i,j}\le r_{i+1,j}$(四边形不等式)</p><p>2.<br>现在题目转化为将区间$[1,n]$分为$m$个区间，区间$[l,r]$的贡献为$f_{l,r}$,求 所有$m$个区间的贡献总和 的最小值<br>设$dp_{i,j}$表示前$i$个石子堆分成$j$个区间的最小值<br>易列出$dp$转移：<br>$dp_{i,j}=min(dp_{k,j-1}+f_{k+1,i})(1\le k&lt;i)$<br>但显然复杂度为$O(n^2m)$过不了<br>那设$g_{i}$为把区间$[1,n]$分成$i$个区间的最小值，即$g_{i}=dp_{n,i}$<br>我们可以发现点$(1,g_{1}),(2,g_{2}),(3,g_{3})…..(n,g_{n})$在二维坐标中为一下凸包(虽然并不会证233)<br>于是就可以通过$dp$凸优化将$dp$有关$m$的一维去掉，此时复杂度$O(n^2logn)$</p><p>3.<br>列出此时的dp转移方程<br>$dp_{i}=min(dp_{j}+f_{j+1,i}-x)(0\le j&lt;i)$<br>$dp$表示取，$x$是二分的斜率，在这里是定值<br>现在又由决策单调性可将其优化成$O(nlogn)$<br>加上二分复杂度，询问复杂度为$O(nlogn^2)$</p><p>总复杂度为$O(n^2+nlogn^2)$</p><h1 id="L-order"><a href="#L-order" class="headerlink" title="L-order"></a>L-order</h1><p>签到题，按照题意模拟即可</p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>shell 基本命令</title>
      <link href="/shell-command/"/>
      <url>/shell-command/</url>
      <content type="html"><![CDATA[<p>显示当前目录内容</p><pre><code>ls </code></pre><p>显示当前文件夹的绝对路径</p><pre><code>pwd</code></pre><p>创建文件夹</p><pre><code>mkdir folder</code></pre><p>进入文件夹</p><pre><code>cd folder</code></pre><p>返回上层目录</p><pre><code>cd ..</code></pre><p>~表示主目录，即/home/username/ 目录，下面命令可以进入到主目录</p><pre><code>cd ~</code></pre><p>创建文件</p><pre><code>touch A.cpp</code></pre><p>ls 一下查看是否创建成功</p><p>后台打开并编辑文件，&amp;表示后台打开</p><pre><code>gedit A.cpp &amp;</code></pre><p>gedit是ubuntu系统自带的文本编辑器,打开后可以在菜单栏对自动缩进，字体，背景等进行简单的设置</p><p>编译A.cpp</p><pre><code>g++ A.cpp -o A</code></pre><p>ls查看当前目录是否增加了一个可执行文件(类似于windows下的exe)，名字为A<br>运行这个可执行文件</p><pre><code>./A</code></pre><p>方向键up，可以查看历史命令</p>]]></content>
      
      <categories>
          
          <category> 辅助技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu安装后的基本配置</title>
      <link href="/linux/"/>
      <url>/linux/</url>
      <content type="html"><![CDATA[<h1 id="为什么要学会使用linux系统"><a href="#为什么要学会使用linux系统" class="headerlink" title="为什么要学会使用linux系统"></a>为什么要学会使用linux系统</h1><p>用了你就知道了</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用U盘制作一个ubuntu 启动盘，建议下载16.04版本的ubuntu-desktop<br>推荐国内下载链接<a href="http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">USTC镜像站</a><br>64位选择amd64.iso,32位的选择i386.iso</p><p>至于如何用U盘安装，网上有很多教程，略过</p><h1 id="安装完成后要做的一些事情"><a href="#安装完成后要做的一些事情" class="headerlink" title="安装完成后要做的一些事情"></a>安装完成后要做的一些事情</h1><h2 id="改源"><a href="#改源" class="headerlink" title="改源"></a>改源</h2><p>组合键ctrl+alt+T 打开terminal</p><p>默认的软件源的下载速度可能比较慢，先换成国内的下载源</p><pre><code>sudo gedit /etc/apt/sources.list</code></pre><p>打开<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a><br>选择你的操作系统版本，复制相应内容到上面的sources.list</p><p>更新</p><pre><code>sudo apt-get update</code></pre><h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><h3 id="editor"><a href="#editor" class="headerlink" title="editor"></a>editor</h3><pre><code>sudo apt install chromium-browser vim emacs git</code></pre><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><p>typora是常用的markdown编辑器，可以在编辑器内实时显示markdown语法解析后的内容</p><p><a href="https://www.typora.io/#linux" target="_blank" rel="noopener">https://www.typora.io/#linux</a></p><p>安装后之后打开，文件-&gt;偏好设置，勾选内联公式</p><h3 id="安装sublime-text"><a href="#安装sublime-text" class="headerlink" title="安装sublime text"></a>安装sublime text</h3><pre><code>wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt-get install apt-transport-httpsecho &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt-get updatesudo apt-get install sublime-text</code></pre><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><p>先到官网下载deb安装包<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">地址</a></p><p>cd 到安装包的目录</p><p>解压并安装</p><pre><code>sudo apt install -fsudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</code></pre><h3 id="安装topcoder"><a href="#安装topcoder" class="headerlink" title="安装topcoder"></a>安装topcoder</h3><p>安装java applet启动器 </p><pre><code>sudo apt install icedtea-netx</code></pre><p>下载topcoder所需文件</p><pre><code>git clone https://github.com/xjoi/topcoder.git</code></pre><p>制作topcoder启动图标</p><pre><code>sudo gedit /usr/share/applications/topcoder.desktop</code></pre><p>填入如下内容</p><pre><code>[Desktop Entry]Version=1.0Name=TopCoderExec=javaws https://community.topcoder.com/contest/arena/ContestAppletProd.jnlpTerminal=falseIcon=/home/software/topcoder/topcoder.jpegType=ApplicationCategories=Development</code></pre><p>Icon一行存放你的topcoder图标所在的目录的绝对路径<br>图标可以用下面这个<br><img src="/img/topcoder.jpeg" alt="图标"></p><p>topcoder 基本的配置可以参考<a href="https://github.com/xjoi/topcoder/blob/master/moj_instructions.txt" target="_blank" rel="noopener">moj_instructions</a></p><h2 id="更新文件英文目录"><a href="#更新文件英文目录" class="headerlink" title="更新文件英文目录"></a>更新文件英文目录</h2><p>中文目录在命令行下会不方便，所以改成英文目录</p><pre><code>export LANG=en_USxdg-user-dirs-gtk-update</code></pre><h2 id="主题的安装"><a href="#主题的安装" class="headerlink" title="主题的安装"></a>主题的安装</h2><p>工具安装</p><pre><code>sudo apt-get install unity-tweak-tool</code></pre><p>安装Flatabulous主题</p><pre><code>sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme</code></pre><p>打开unity-tweak工具，在主题栏目里面选择相应主题</p><h2 id="安装monaco字体"><a href="#安装monaco字体" class="headerlink" title="安装monaco字体"></a>安装monaco字体</h2><pre><code>cd /usr/share/fonts/truetype/sudo mkdir ttf-monacocd ttf-monaco/sudo wget http://codybonney.com/files/fonts/Monaco_Linux.ttfsudo mkfontdircd ..fc-cache</code></pre><p>字体的使用可以点开左上角菜单栏 编辑-&gt;配置文件首选项</p><p>下面是一个截图</p><p><img src="/img/ubuntu.png" alt="ubuntu"></p>]]></content>
      
      <categories>
          
          <category> 辅助技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>结构体的妙用</title>
      <link href="/cplusplus-basic/"/>
      <url>/cplusplus-basic/</url>
      <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高精度</title>
      <link href="/bigint/"/>
      <url>/bigint/</url>
      <content type="html"><![CDATA[<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分查找</title>
      <link href="/binary-search/"/>
      <url>/binary-search/</url>
      <content type="html"><![CDATA[<h1 id="lower-bound-amp-upper-bound"><a href="#lower-bound-amp-upper-bound" class="headerlink" title="lower_bound &amp; upper_bound"></a>lower_bound &amp; upper_bound</h1><h1 id="最大化最小值"><a href="#最大化最小值" class="headerlink" title="最大化最小值"></a>最大化最小值</h1><h1 id="尺取法-two-pointers"><a href="#尺取法-two-pointers" class="headerlink" title="尺取法(two-pointers)"></a>尺取法(two-pointers)</h1><h1 id="最大化平均值"><a href="#最大化平均值" class="headerlink" title="最大化平均值"></a>最大化平均值</h1>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速幂</title>
      <link href="/fast-pow/"/>
      <url>/fast-pow/</url>
      <content type="html"><![CDATA[<h1 id="位运算入门"><a href="#位运算入门" class="headerlink" title="位运算入门"></a>位运算入门</h1><h1 id="快速幂原理"><a href="#快速幂原理" class="headerlink" title="快速幂原理"></a>快速幂原理</h1>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>加入我们</title>
      <link href="/join-us/"/>
      <url>/join-us/</url>
      <content type="html"><![CDATA[<h1 id="学军中学信息学团队简介"><a href="#学军中学信息学团队简介" class="headerlink" title="学军中学信息学团队简介"></a>学军中学信息学团队简介</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTI5NDE0NA==&amp;mid=2666994521&amp;idx=1&amp;sn=9b3ca2da4b8c65afe2e4fce8e7d2c76f&amp;chksm=84d99676b3ae1f60685db01456e0b89b76f99fabef438bfbfefe151091bd8f64a2f7aaead17f&amp;mpshare=1&amp;scene=1&amp;srcid=1127UFUupcYl71jRXNb9dZ05&amp;pass_ticket=LacnTfviSXFAeTp9YQ89sS0rlMwuhaAC6iTw1s2CBkNHfebEYyXgO6pR6OootF54#rd" target="_blank" rel="noopener">最新战绩</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTI5NDE0NA==&amp;mid=2666993992&amp;idx=1&amp;sn=6d5b4ce308e6258cb9a8a69c2aa24bd5&amp;chksm=84d99467b3ae1d7140cc0f6a6d3f521b29301ee69d12a78afc1c76bc5da3658c272625b476fe&amp;mpshare=1&amp;scene=1&amp;srcid=1127IZyYdwcmn87i0O1QgIce&amp;pass_ticket=LacnTfviSXFAeTp9YQ89sS0rlMwuhaAC6iTw1s2CBkNHfebEYyXgO6pR6OootF54#rd" target="_blank" rel="noopener">以往成就</a></p><h1 id="教练生活"><a href="#教练生活" class="headerlink" title="教练生活"></a>教练生活</h1><p>你是否想象过边打比赛还能边工作的生活，没错，OI教练就能满足你</p><p>信息学竞赛会在未来几年达到一个巅峰状态，越来越多的学生想要参与进来</p><p>作为信息竞赛教练，我们经常要跟学生一起并肩作战，通过一场场网络赛，一轮轮现场赛的锻炼，全面提升学生的能力，培养他们不怕苦难的品格</p><p>同时我们也会自己举办一系列的比赛，比如我们承办了2018年的浙江省NOIP复赛，未来还会有更多惊喜</p><p>当然，作为教练，带学生出去比赛是家常便饭，跟我们以前做选手是类似的，只不过角色变了</p><p>工作的时间上是周期性的，一般每年的比赛季（暑假一直到11月份）是最忙的，比赛结束后都会开始总结与筹备下一年的发展</p><p>总之，这一行需要对算法竞赛本身非常热爱的人加入，你们参加竞赛之初的那份热爱会体现在孩子们每天的成长之上</p><p>我们的目标是培养一大批计算机拔尖人才，大部分人能走上国内一流的名校</p><p>如今，一小撮尖子生的时代已经过去了，如何让一大批人都能学得更好是我们一直在在做的</p><p>工作目标就是一个：学生打出好成绩</p><h1 id="招聘要求"><a href="#招聘要求" class="headerlink" title="招聘要求"></a>招聘要求</h1><ul><li>女士优先(本校女选手越来越多，教练团队也要同步跟上)</li><li>ICPC/CCPC铜牌或以上(每个级别我们会对您有不同的工作安排)</li><li>2019年毕业或者已经工作过的都可以（如果是2020年毕业离杭州近的，也可以考虑先来实习体验）</li><li>熟悉linux，独立开发过一些项目,尤其是熟悉OJ开发的会加分（因为我们需要不停的开发内部平台）</li><li>最重要的一点是热爱算法竞赛，愿意全力帮助青少年，使他们少走弯路</li></ul><h1 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h1><ul><li>根据不同竞赛经历的人不太一样，所以如果感兴趣，可以面谈, 数量上不低于一线互联网公司</li></ul><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>发送简历到下方的邮箱，如果感觉合适，我们会与您联系</p><p>email: <a href="mailto:problem_solving@foxmail.com" target="_blank" rel="noopener">problem_solving@foxmail.com</a></p>]]></content>
      
      <categories>
          
          <category> 加入我们 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 招聘 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/bfs/"/>
      <url>/bfs/</url>
      <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种线性数据结构，其结构就跟我们平时排队是一样的，有一个人在头，一个人在尾，队伍中的人当前都在队列中，我们注意到这种普通的队列可能会有两种操作</p><ul><li>删除一个头节点（排在第一的人完成了任务，走了）</li><li>插入一个尾节点（多一个人来排队）</li></ul><p>由上我们知道队列满足先进队先出队的性质，简称先进先出</p><p>在代码实现上我们一般用一个数组来模拟队列，用两个变量来模拟队列的头尾在数组中的位置</p><h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><blockquote><p>给你一个 nxm的地图，‘@’是你所在的位置，’#’是障碍，不能经过，’.’ 是空地，可以经过，你只能往上下左右四个方向行走，现在问你最多可以走到多少个位置，包括你自己所处的位置。</p></blockquote><pre><code>9 11.#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ...........输出：59</code></pre><p>这道题我们可以利用队列来扩展还没有访问过的空地，用一个二维数组来标记某个位置是否访问过，访问过的位置不用再管，每次从队列中取出一个队头元素，去看看它的上下左右是否还有新的空地，有的话就加入队尾，下面是代码实现</p><pre><code class="c">#include &lt;bits/stdc++.h&gt;using namespace std;struct node {    int x, y;    //队列中的每个元素的信息};char mp[100][100];node Q[1000]; // 保存队列的数组int vis[22][22];int dx[] = {1, 0, -1, 0};int dy[] = {0, 1, 0, -1};void bfs(int n, int m, int sx, int sy) {    int head = 0, tail = 0; // 队头的位置与队尾的位置    Q[tail].x = sx;    Q[tail].y = sy;    tail++;    vis[sx][sy] = 1; //一开始将起点放入队列开始广搜    while (head &lt; tail) { // 当队列非空时，不断取出队头的元素        node front = Q[head]; head++;        int nowx = front.x;        int nowy = front.y;        for (int i = 0; i &lt; 4; i++) { // 向队头元素的四周扩展            int tox = nowx + dx[i];            int toy = nowy + dy[i];            //越界检查 障碍判断 是否已经访问过            if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m || mp[tox][toy] == &#39;#&#39; || vis[tox][toy]) {                continue;            }            //发现新大陆            vis[tox][toy] = 1;            Q[tail].x = tox;            Q[tail].y = toy;            tail++;        }    }    printf(&quot;%d\n&quot;, tail);}int main() {    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int sx =-1, sy = -1;    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%s&quot;, mp[i]);                    for (int j = 0; j &lt; m; j++) {            if( mp[i][j] == &#39;@&#39;) {                sx = i;                sy = j;            }        }    }    bfs(n, m, sx, sy);    return 0;}</code></pre><p><strong>当然这还没有完全体现出队列的功能，下面我们再看一道例题</strong></p><h1 id="骑士出行"><a href="#骑士出行" class="headerlink" title="骑士出行"></a>骑士出行</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>告诉你一个棋盘的大小，问你从棋盘的一个点走到另一个点的最小步数，走的规则是国际象棋中骑士的走法，即走日字形</p></blockquote><p><img src="/img/knight.jpg" alt="knight"></p><p>我们观察第一个例题中的队列扩展的过程其实是由近及远扩展的，每一个新的节点都是以最少的步数扩展到的，这个很显然，因为一开始0步的能走到所有距离起点为1的点，所有距离起点为2的点都是由距离起点为1的点扩展到的，以此类推。<br>因此我们考虑在将每个点扩展进队列的时候顺便增加一个信息，就是这个点距离起点的距离，那么我们就可以在广搜的过程中顺便求出每个点到起点的最短路径了<br>因为在搜索的过程中队列的扩展形式是一层层往外扩展的，所以得名广度优先搜索</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;//八个方向int dx[] = {1, 1, 2, 2, -1, -1, -2, -2};int dy[] = {2, -2, 1, -1, 2, -2, 1, -1};int queue[90010][3]; // 保存队列，包含三个信息，x坐标，y坐标，与起点之间的距离int flag[310][310]; //标记某个点是否走过了int main() {        int t, n;        int bfs(int, int, int , int, int);        scanf(&quot;%d&quot;, &amp;n);        for(int i = 0; i &lt; n; i++) {                for(int j = 0; j &lt; n; j++) {                        flag[i][j] = 0;                }        }        int sx, sy, tx, ty;        scanf(&quot;%d%d%d%d&quot;, &amp;sx, &amp;sy, &amp;tx, &amp;ty);        int ret = bfs(sx, sy, tx, ty, n);        printf(&quot;%d\n&quot;, ret);        return 0;}int bfs(int sx, int sy, int tx, int ty, int n) {        if(sx == tx &amp;&amp; sy == ty) {                return 0;        }        flag[sx][sy] = 1;        int head = 0, tail = 0;        queue[tail][0] = sx;        queue[tail][1] = sy;        queue[tail][2] = 0;        tail++;        while(head &lt; tail) {                int x = queue[head][0];                int y = queue[head][1];                int step = queue[head][2];                head++;                for(int i = 0; i &lt; 8; i++) {                        int nowx = x + dx[i];                        int nowy = y + dy[i];                        if(nowx &lt; 0 || nowx &gt;= n || nowy &lt; 0 || nowy &gt;= n) {                                continue;                        }                        if(flag[nowx][nowy] == 1) {                                continue;                        }                        if(nowx == tx &amp;&amp; nowy == ty) {                                return step + 1;                        }                        flag[nowx][nowy] = 1;                        queue[tail][0] = nowx;                        queue[tail][1] = nowy;                        queue[tail][2] = step + 1; //距离等于搜到它的点的距离 加 1                        tail++;                }        }}</code></pre><h1 id="营救计划"><a href="#营救计划" class="headerlink" title="营救计划"></a>营救计划</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><blockquote><p>在一个nxm的迷宫里，有一个萌新被困住了，你作为一个久经码场的战士，决定去营救萌新。地图中还会有一些守卫，你必须打败守卫才能通过守卫所在的位置，打败守卫需要花费1分钟，移动一步需要花费一分钟，每次你只能往上下左右某个方向移动一步。问你最少需要花费多少时间才能救到萌新。</p></blockquote><pre><code>7 8 #.#####. #.M#..@. #..#G... ..#..#.# #...##.. .#...... ........132 2M.G@2</code></pre><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>此问题的关键在于当我们搜到守卫的时候，能否将守卫直接放入队列，如果直接放入队列就要将时间直接加上2分钟，那么队列中就会出现时间花费较大的元素排在时间花费较少的元素前面，具体见上面第二个例子，所以从这里我们可以看出队列中元素的步长一定要满足非递减的顺序</p><p>那么该如何解决这个问题呢？</p><p>假如我们学过优先队列，我们可以直接将时间+2然后插入队列，因为这个元素会自动排在时间较小的元素后面</p><p>如果还是用普通的队列可以这样处理：碰到守卫先当作普通的空地一样放入队列，等到取出来的时候，不去扩展周边的格子，而是重新放回队列，并且步数加1</p><p>这样子，还是满足了队列的性质，一层层向外扩展，队列中的元素的步长是每次严格的+1</p><p>参考代码</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int n,m,x0,y0,k;int flag[201][201];char str[201][201];int step[4][2]={-1,0,1,0,0,1,0,-1};struct node{    int x,y;    int steps;}move[400002];int bfs(){    int i,head,rear,tempx,tempy;    move[1].x=x0;move[1].y=y0;    move[1].steps=0;    head=0;rear=1;    while(head&lt;rear)    {        head++;        if(str[move[head].x][move[head].y]==&#39;G&#39;)        {            rear++;            move[rear].x=move[head].x;            move[rear].y=move[head].y;            move[rear].steps=move[head].steps+1;            str[move[head].x][move[head].y]=&#39;.&#39;;        }        else        {            for(i=0;i&lt;4;i++)            {                tempx=move[head].x+step[i][0];                tempy=move[head].y+step[i][1];                if(tempx&lt;0||tempx&gt;=n||tempy&lt;0||tempy&gt;=m||flag[tempx][tempy]||str[tempx][tempy]==&#39;#&#39;)                    continue;                flag[tempx][tempy]=1;                rear++;                move[rear].x=tempx;                move[rear].y=tempy;                move[rear].steps=move[head].steps+1;                if(str[tempx][tempy]==&#39;M&#39;)                    return move[rear].steps;            }        }    }    return 0;}int main(){    int i,j,ans;    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2)    {        memset(str,&#39;\0&#39;,sizeof(str));        memset(flag,0,sizeof(flag));        for(i=0;i&lt;n;i++)            for(j=0;j&lt;m;j++)            {                scanf(&quot;%1s&quot;,&amp;str[i][j]);                if(str[i][j]==&#39;@&#39;)                {                    x0=i;y0=j;                    str[i][j]=&#39;#&#39;;                }            }            ans=bfs();            if(ans) printf(&quot;%d\n&quot;,ans);            else printf(&quot;You can&#39;t save Mengxin\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 广搜 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018noip题解以及点评</title>
      <link href="/2018noip-solution/"/>
      <url>/2018noip-solution/</url>
      <content type="html"><![CDATA[<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="T1-道路铺设"><a href="#T1-道路铺设" class="headerlink" title="T1-道路铺设"></a>T1-道路铺设</h2><p>暑假里给学生讲这种模型的时候讲到有四种方法可以做这样的题<br>1：RMQ<br>2：单调栈<br>3：迪卡尔树<br>4：看似暴力的预处理<br>就算没做过原题，不知道差分，随便写一种方法都不会花很长时间</p><h2 id="T2-货币系统"><a href="#T2-货币系统" class="headerlink" title="T2-货币系统"></a>T2-货币系统</h2><p>一看到这个题可能有点紧张，然后看看数据范围基本就能联想到背包<br>想到背包这个题基本就没有了秘密</p><h2 id="T3-赛道修建"><a href="#T3-赛道修建" class="headerlink" title="T3-赛道修建"></a>T3-赛道修建</h2><p>首先根据提高组选手的基本素养，立刻反应要二分<br>二分之后怎么验证呢<br>我们可以枚举路径的LCA，那么一条合法路径就被分成了两条从LCA出发的路径，当然如果某条从LCA出发的路径足够长，自己也可以构成一条路径<br>我们发现每个子树要么自己配对完毕，要么留下一条路径延伸到父亲方向去<br>留下两条或以上没有意义<br>因此如果实在要留，我们尽可能留下最长的那条路径<br>只要两条路径的长度加起来&gt;=K就可以配成一对，因此现在变成了一个子问题<br>给你一个数组，问你最多配成多少对的和&gt;=K的整数对<br>从小到大枚举每个数然后在set里面二分找最小的数去陪对就好了</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55555;vector &lt;pair&lt;int, int&gt; &gt; e[N];int n, m;int w[N];int total;void dfs(int u, int f, int x) {    if (total &gt;= m) {        return ;    }    multiset &lt;int&gt; st;    for (auto it : e[u]) {        if (it.first != f) {            dfs(it.first, u, x);            if (total &gt;= m) {                return ;            }            int value = w[it.first] + it.second;            if (value &gt;= x) {                total++;            } else {                st.insert(value);            }        }    }    if (total &gt;= m) {        return ;    }    int left = 0;    while (!st.empty()) {        auto it = st.begin();        int value = *it;        st.erase(it);        if (*it &gt;= x) {            total ++;            continue;        }        auto it_pair = st.lower_bound(x - *it);        if (it_pair == st.end()) {            left = max(left, value);        } else {            total ++;            st.erase(it_pair);        }    }    w[u] = left;}bool judge (int x) {    total = 0;    dfs(0, -1, x);    return total &gt;= m;}int main () {    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int a, b, c;    for (int i = 1; i &lt; n; i++) {        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        a--; b--;        e[a].push_back(make_pair(b, c));        e[b].push_back(make_pair(a, c));    }    int l = 1, r = 500000000, best = -1;    while (l &lt;= r) {        int mid = (l + r) &gt;&gt; 1;        if (judge (mid)) {            best = mid;            l = mid + 1;        } else {            r = mid - 1;        }    }    printf(&quot;%d\n&quot;, best);    return 0;}</code></pre><h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="T1-旅行"><a href="#T1-旅行" class="headerlink" title="T1-旅行"></a>T1-旅行</h2><p>树的情况显然可以直接贪心每次走编号小的儿子<br>图的情况，稍微分析一下发现有一条边可以不走，然后看到数据范围就可以想到暴力枚举了</p><h2 id="T2-填数游戏"><a href="#T2-填数游戏" class="headerlink" title="T2-填数游戏"></a>T2-填数游戏</h2><p>首先打出8*7以内的表,然后发现</p><p>$$ f[n][m]= 3* f[n][m - 1] (m &gt;= n-2) $$</p><p>那么我们只需要搞出8x9以内的就万事大吉<br>那么我们开个O2大力打出8x8的表，你会发现</p><p>$$f[n][n+1] = f[n][n] * 3 + d$$<br>d是个等比数列，然后8x9的答案可以推算出来<br>8×8需要跑一小会，搜索写的好一点可以更快地打出8x8</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = (int)1e9+7;vector &lt;pair&lt;int,int&gt; &gt; v[100];int a[8][8];int cnt;int n, m;bool check() {    for (int i = 1; i &lt; n; i++) {        for (int j = 1; j &lt; m; j++) if (a[i - 1][j] == a[i][j - 1]){            for (int xie = i + j + 1; xie &lt; n + m - 1; xie++) {                int col = -1;                int state = 0;                for (int k = 0; k &lt; v[xie].size(); k++) {                    auto it = v[xie][k];                    if (it.first &gt;= i &amp;&amp; it.second &gt;= j) {                        state |= (1 &lt;&lt; a[it.first][it.second]);                    }                    if (state == 3) {                        return false;                    }                }            }        }    }    return true;}void dfs(int tot, int now) {    //printf(&quot;tot=%d now=%d\n&quot;, tot, now);    if (now == tot) {        if (check()) {            cnt++;        }        return ;    }    for (int i = 0; i &lt; v[now].size(); i++) {        pair&lt;int,int&gt; it = v[now][i];        a[it.first][it.second] = 1;    }    dfs(tot, now + 1);    for (int i = 0; i &lt; v[now].size(); i++) {        pair&lt;int,int&gt; it = v[now][i];        a[it.first][it.second] = 0;        dfs(tot, now + 1);    }}int brute(int n, int m) {    ::n = n;    ::m = m;    cnt = 0;    for (int i = 0; i &lt; 100; i++) v[i].clear();    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; m; j++) {            v[i+j].push_back(make_pair(i, j));        }    }    dfs(n + m - 1, 0);    return cnt;} int biao[][10] = { {2,4,8,16,32,64,128,256}, {4,12,36,108,324,972,2916,8748}, {8,36,112,336,1008,3024,9072,27216}, {16,108,336,912,2688,8064,24192,72576}, {32,324,1008,2688,7136,21312,63936,191808}, {64,972,3024,8064,21312,56768,170112,510336}, {128,2916,9072,24192,63936,170112,453504,1360128}, {256,8748,27216,72576,191808,510336,1360128,3626752, 10879488}};int pow_mod(int a, int b) {    int ret = 1;    while (b) {        if (b &amp; 1) {            ret = 1LL * ret * a % mod;        }        a = 1LL * a * a % mod;        b &gt;&gt;= 1;    }    return ret;}int main () {    /*    for (int i = 8; i &lt;= 8; i++) {        printf(&quot;i=%d\n&quot;, i);        cout &lt;&lt; &#39;{&#39;;        for (int j = 8; j &lt;= 8; j++) { //           printf(&quot;i=%d j=%d\n&quot;, i, j);            printf(&quot;%d, \n&quot;, brute(i, j));        }        cout &lt;&lt; &#39;}&#39; &lt;&lt; endl;    }*/    biao[6][8] = biao[6][7] * 3;    biao[6][9] = biao[6][8] * 3;    biao[7][9] = biao[7][8] * 3;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    if (n == 1) {        cout &lt;&lt; pow_mod(2, m) &lt;&lt; endl;        return 0;    }    n --;    m --;    if (m &gt;= 7 &amp;&amp; m &gt;= n + 2) {        cout &lt;&lt; 1LL * biao[n][n + 2] * pow_mod(3, m - n - 2) % mod;    } else {        cout &lt;&lt; biao[n][m]  &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="T3-保卫王国"><a href="#T3-保卫王国" class="headerlink" title="T3-保卫王国"></a>T3-保卫王国</h2><p>首先，只要会基本的树形DP就可以拿到44分</p><p>对于正解，我们先观察一下钦点一个点的状态的时候该怎么做<br>如果钦点了一个点的状态，我们需要自底向上DP一遍，然后再从上往下再DP一遍<br>这样子我们可以预处理出两个东西<br>f[u][0/1]: u选或者不选的情况下u子树的最优值<br>g[u][0/1]：u选或者不选的情况下整棵树的最优值</p><p>然后再进一步，我们来思考钦点两个点怎么做</p><p>我们发现钦点两个点其实就是会影响这两个点的LCA子树内的DP状态，把这个子树拿掉后的其他点的代价可以利用前面处理出来的数组快速算出来</p><p>于是就可以考虑用倍增算法来预处理出如下数组</p><p>qd[i][j][x][y]<br>表示j的状态为x,j的2的i次方个祖先的状态为y的情况下的最优值，这个dp满足区间合并的性质，合并起来类似于矩阵乘法的转移</p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 300010;const int MAX_POW = 19;const long long INF = (long long) 1e12;vector &lt;int&gt; e[N];int val[N], dep[N];int p[MAX_POW][N];long long f[N][2], g[N][2];struct state{    long long a[2][2];    void init() {        a[0][0] = a[0][1] = a[1][1] = a[1][0] = INF;    }    void print() {        for (int i = 0; i &lt; 2; i++) {            for (int j = 0; j &lt; 2; j++) {                printf(&quot;a[%d][%d] = %lld\n&quot;, i, j, a[i][j]);            }        }        puts(&quot;&quot;);    }}qd[MAX_POW][N];int n, m;void input () {    scanf(&quot;%d%d%*s&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%d&quot;, &amp;val[i]);    }    int a, b;    for (int i = 1; i &lt; n; i++) {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        a--; b--;        e[a].push_back(b);        e[b].push_back(a);    }}void dfs(int u, int pre) {    if(pre != -1) dep[u] = dep[pre] + 1;    p[0][u] = pre;    f[u][0] = 0;    f[u][1] = val[u];    for (auto v: e[u]) if (v != pre){        dfs(v, u);        f[u][0] += f[v][1];        f[u][1] += min(f[v][0], f[v][1]);    }}void rdfs(int u, int pre, int pf0, int pf1) {    g[u][0] = f[u][0] + pf1;    g[u][1] = f[u][1] + min(pf0, pf1);    for (auto v: e[u]) if (v != pre) {        qd[0][v].a[0][0] = INF;        qd[0][v].a[0][1] = qd[0][v].a[1][1] = f[u][1] - min(f[v][0], f[v][1]);        qd[0][v].a[1][0] = f[u][0] - f[v][1];        rdfs(v, u, g[u][0] - f[v][1], g[u][1] - min(f[v][0], f[v][1]));    }}state merge(const state&amp; A, const state&amp; B) {    state res;    for (int i = 0; i &lt; 2; i++) {        for (int j = 0; j &lt; 2; j++) {            res.a[i][j] = INF;            for (int k = 0; k &lt; 2; k++) {                res.a[i][j] = min(res.a[i][j], A.a[i][k] + B.a[k][j]);            }        }    }    return res;}void init() {    memset(p, -1, sizeof(p));    dfs(0, -1);    for (int i = 1; i &lt; MAX_POW; i++) {        for (int u = 0; u &lt; n; u++) {            p[i][u] = p[i - 1][p[i - 1][u]];        }    }    rdfs(0, -1, 0, 0);    for (int i = 1; i &lt; MAX_POW; i++) {        for (int u = 0; u &lt; n; u++) {            qd[i][u] = merge(qd[i-1][u], qd[i-1][p[i - 1][u]]);        }    }}void query() {    int ua,x,ub,y;    for (int i = 0; i &lt; m; i++) {        scanf(&quot;%d%d%d%d&quot;, &amp;ua, &amp;x, &amp;ub, &amp;y);        ua--; ub--;        if (dep[ua] &lt; dep[ub]) {            swap(ua, ub);            swap(x, y);        }        int delta = dep[ua] - dep[ub];        state left; left.init(); left.a[x][x] = f[ua][x];        state right; right.init(); right.a[y][y] = f[ub][y];        for (int i = MAX_POW - 1; i &gt;= 0; i--) if (delta &gt;&gt; i &amp; 1){            left = merge(left, qd[i][ua]);            ua = p[i][ua];        }        if (ua == ub) {            long long res = left.a[x][y];            int fa = p[0][ub];            if (fa != -1) {                long long c0 = g[fa][0] - f[ub][1];                long long c1 = g[fa][1] - min(f[ub][0], f[ub][1]);                if (y == 0) {                    res += c1;                } else {                    res += min(c0, c1);                }            }            printf(&quot;%lld\n&quot;, res &gt;= INF ? -1 : res);        } else {            for (int i = MAX_POW - 1; i &gt;= 0; i--) if (p[i][ua] != p[i][ub]) {                left = merge(left, qd[i][ua]);                right = merge(right, qd[i][ub]);                ua = p[i][ua];                ub = p[i][ub];            }            int lca = p[0][ua];            long long c0 = g[lca][0] - f[ua][1] - f[ub][1];            long long c1 = g[lca][1] - min(f[ua][0], f[ua][1]) - min(f[ub][0], f[ub][1]) ;            c0 += left.a[x][1] + right.a[y][1];            c1 += min(left.a[x][0], left.a[x][1]) + min(right.a[y][0], right.a[y][1]);            printf(&quot;%lld\n&quot;, min(c0, c1) &gt;= INF ? -1 : min(c0, c1));        }    }}int main() {    input();    init();    query();    return 0;}</code></pre><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><p>day1三题属于送分题，尤其T1有四五种方法可以做, T2只要大力背包，T3这种二分之后树上贪心的套路也已经屡见不鲜</p><p>day2-T1考察图论基本功，T2没有什么思路首先都会去打表，而且这个题打出8*7以内的表非常容易，几分钟就能跑出答案，观察这个表的规律就可以拿到大部分的分数了，T3比较坑，这本来就是一道原题，而且这种第一次见基本做不出来的题出在了一场决定很多选手命运的比赛中确实不太合适，尽管暴力分给的还算多</p><p>总的来说，今年的题目远远不及前两年, 原题或者类原题实在多了点,思维上也没有什么亮点</p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello-world</title>
      <link href="/hello-world-md/"/>
      <url>/hello-world-md/</url>
      <content type="html"><![CDATA[<h1 id="开启新世界的程序"><a href="#开启新世界的程序" class="headerlink" title="开启新世界的程序"></a>开启新世界的程序</h1><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main() {    printf(&quot;hello world\n&quot;);    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的一些入门必备知识</title>
      <link href="/tree-basic/"/>
      <url>/tree-basic/</url>
      <content type="html"><![CDATA[<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1>]]></content>
      
      <categories>
          
          <category> 提高 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> dfs序 </tag>
            
            <tag> 重心 </tag>
            
            <tag> 直径 </tag>
            
            <tag> 欧拉序列 </tag>
            
            <tag> 最近公共祖先 </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018noip游记</title>
      <link href="/2018noip/"/>
      <url>/2018noip/</url>
      <content type="html"><![CDATA[<h1 id="day-6-7-8"><a href="#day-6-7-8" class="headerlink" title="day -6 -7 -8"></a>day -6 -7 -8</h1><p>编写本次比赛需要用到的所有脚本，linux一份，windows一份<br>考虑各种作弊的可能性，并结合软硬件消除所有能想到的作弊方法,这个会在下文给出<br>下面进入本次noip精(dar)彩(k)连续剧情</p><h1 id="day-5-晚"><a href="#day-5-晚" class="headerlink" title="day -5 晚"></a>day -5 晚</h1><p>“操作系统好像是64位的，不行，全部都得改成32位的”</p><p>“%^$#@*&amp;~”</p><p>“今晚通宵重新做母盘，明天全部重新克隆”</p><p>“笔记本好像没有克隆技术，只能一台台用U盘/移动硬盘 刻”</p><p>“&amp;^%$!@#!$!%%^^%”</p><h1 id="day-4"><a href="#day-4" class="headerlink" title="day -4"></a>day -4</h1><p>全盘镜像失败，去紫金港那边查看情况，经过一个上午的努力，windows总算能刻录了，但是双系统依然无法刻录<br>各种尝试失败后发现直接取代原有双系统种的windows，并不会影响linux，启动引导都还在，反正linux并不需要做任何的配置与软件安装，于是就决定对720台电脑全部修改windows系统。<br>刻了大概20台电脑时突然发现没有装还原软件，重新装好，继续重新刻，还好不是刻完了才发现这个问题<br>装还原软件的时候，随手设了一个比较长的密码，事实证明，这是个错误的决定。。。<br>到了晚上11点时，大概已经有五六百台电脑已经刻好，第二天准备进入紫金港校区开始实地联网测试</p><h1 id="day-3"><a href="#day-3" class="headerlink" title="day -3"></a>day -3</h1><p>上午</p><p>到了现场，发现桌子不够长，每个人只有60公分长，比赛的时候很容易互相伤害。<br>于是赶紧加桌子<br>等720台电脑送到时，已经是接近中午，帮着卸货，扛了一会儿电脑。。连续熬夜表示体力不支</p><p>下午</p><p>技术上的测试还完全做不了，只能先干点杂活了。<br>首先开始摆放电脑，摆了一个双系统区的电脑，想进行简单的网络连通性测试，不过网线，电源线，都需要人手来连接<br>与网络负责人交接网络的布局，本来是准备每个区120台电脑，各自一个局域网，实际到了现场一看发现不现实，<br>那样的话每个局域网收发试卷都需要有人在，由于网络异常，死机等问题导致程序卡住了，都需要及时作出调整，那就至少需要六个人盯着<br>由于人手很明显不够，于是决定所有的网络汇聚到主席台上，直接在主席台上摆放7台服务器，每台负责一个区域，5个windows区，一个windows/linux混合区<br>事实证明，这个选择非常正确，因为到了比赛当天，周老师被调去负责另外多出来的一个机房了，于是现场就剩下了我和余姚中学过来帮忙的一行兄。</p><p>于是当天就在杂七杂八的事情中过去了，跟比赛相关的测试还完全没有动过。</p><h1 id="day-2"><a href="#day-2" class="headerlink" title="day -2"></a>day -2</h1><p>一整天都在ping ip中度过, 那几天做梦都在ping ip<br>现场测试发现网络不通的主要原因有网线松了，交换机没配好，电脑没电了，ip没设对等<br>碰到网络连不上，就得一台台看过去, 于是这里需要一些人手，当晚应该是联通了几个区的网络的，还剩一两个区没动</p><h1 id="day-1"><a href="#day-1" class="headerlink" title="day -1"></a>day -1</h1><p>考前压力测试，造成了一定程度的混乱，这里就不多说了<br>day -1 也继续在调网络，顺便对几个区块进行了考试的模拟。批量下发题目，收代码，D盘备份等。网络通的几个区域是比较顺利的<br>利用现场几百台电脑，顺便优化了一下代码，调了调参数。</p><h1 id="day0"><a href="#day0" class="headerlink" title="day0"></a>day0</h1><p>mac地址绑定，以及绑定后的重新测试，已经是最后一天了。时间非常紧张<br>为什么要做绑定呢？这样可以避免因为选手发现现场IP设置的规律，而把ip改成对方的ip，或者选手瞎改ip造成ip地址冲突影响别人<br>结合代码，每个ip只收取这个ip对应考号的文件夹，如果考生改变了D盘下的文件夹名字，这台电脑的成绩就会作废<br>linux下不需要做设置，因为用户名就是考号，考生没有权限修改用户名<br>在技术没做到位的情况下，可能的作弊方案是: 两个人day1看到自己的ip，day2互换ip，以及互改考生文件夹，这样在服务器上收上来看就好像什么都没发生一样<br>然后其他的作弊方法应该就是去厕所交换思路了或者上完厕所回来换了个位置了，这属于监考老师管理的范畴了<br>晚上九点，网络终于全线联通了，真是令人感动, 差一点点就GG了，所有的事情都差那么一点点药丸<br>当晚周老师通宵编辑每个服务器上的ip-用户对照表以及重新测试网络，记录有问题的电脑，我实在扛不住，去睡了四五个小时</p><h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><p>正式比赛开始，看见将近700个考生齐刷刷的走进来，想想昨天晚上所有的工作才就绪…<br>由于网络是通的，发卷没有出现太大问题<br>OI比赛没有太多看头，考完考生也没法留在赛场上合影之类的，相对ICPC来说乐趣少了很多<br>比赛过程中有些选手说dev编译出了问题，去看了一下一般是没有选择编译成32位的下拉菜单<br>这次比赛其实给windows选手准备了好几个编辑器的，比如gvim,sublime,vscode<br>不过大家好像都只会一键编译，并不会使用命令行编译，这个会让选手吃一些亏，因为考前须知里面明确写了环境变量的g++编译器版本是4.8.4，这个版本与评测机的版本一致<br>比较科学的做法是最后都要用这个版本把所有的程序编译一遍看看会不会CE<br>发现还有一些选手非常依赖于单步调试，ide一变，可能就不适应了。<br>还有一些奇怪的问题。<br>比如cpp文件默认显示的图标不是dev的图标，这个怎么办</p><p>12点一到，比赛结束，考生离场，开始收卷</p><p>收卷过程非常顺利，十几分钟时间，所有的代码都已经收完，接下来开始合并服务器上收到的代码<br>收代码的过程要收两份，一份是整个D盘下的所有文件，linux则是整个主文件夹下的所有文件<br>第二份是只与考试相关的考生文件夹下的内容，并且要尽可能的去除无关文件<br>做法就是先收备份，然后从备份里面筛选出需要的内容上交给CCF<br>由于一些选手比赛过程中采用了打表等手段，备份文件可能会非常大<br>加上第一天没经验，忘了过滤回收站，于是有些选手的回收站中的几万个文件也被收了上来</p><p>提高组day1由于汇总试卷与检查环节花了很长时间，导致普及组考试开始前的二十分钟才清空好所有电脑，并下发试卷</p><p>2：30 普及组比赛正式开始<br>受制于初中教学资源的匮乏，普及组用pascal的选手还是非常多的，一般的问题都是跟IDE有关，可能部分选手在家里用的版本跟考试的版本不太一样，就无法适应<br>这种情况一般就是让选手使用备选软件里面的其他版本的IDE</p><p>其中有个小孩，比赛过程中似乎碰到了一些小问题，我也不记得了，过去的时候他很紧张，帮他解决完之后，小家伙谢谢谢谢的说个不停</p><p>赛后做了一个编译检查，查有没有乱码，结果发现普及组爆0的情况非常多，大部分是文件名打错或者目录建错，实在是太惨了。<br>要不以后还是跟初中生一起玩吧，感觉他们更需要支持。</p><h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p>本来想day1晚上就把所有准备工作做好的，结果突然被拉去吃饭，于是那天晚上准备工作就没做<br>到了day2的早上，我发现linux区加用户的功能出了点问题，可能day1的时候改过代码，调来调去都不太行，还好有周老师在帮忙发完了ABCDE区的所有试卷<br>这时候他去另一个机房了，我好像还没有把代码改对，由于没有加版本控制，之前的版本也找不回来了，离选手入场大概还有十分钟，我假装什么事情也没有发生<br>周围人好像也不知道我这边发不了卷。<br>然后我冷静了一下，好像邮箱里面还剩下一份之前测试成功过的代码，于是赶紧下载下来，跑了跑还能用<br>于是立刻创建用户，发卷，重启<br>于是就发生了linux用户刚进场，电脑正在重启的一幕，据说把本校的一个小女生给吓坏了…</p><p>比赛过程十分顺利，没有出现什么奇怪的问题</p><p>这次day2我们经过day1的总结，计划在一个小时内完成所有的收卷汇总检查工作<br>12：30左右收完所有区域的代码（有几个选手考试的时候由于电脑问题，有加时）<br>然后这次我们先不筛选代码，直接将选手文件夹交给赵主任，然后自己这边同步筛选，这样就是双线程工作了，筛选完成后，一行兄那边立刻开始在noilinux上跑编译检查<br>效率非常高，最终一个小时不到完成任务</p><p>由于本次比赛是在一个环境里面，所以基本没有看到过乱码的现象，不过也不知道有没有漏网之鱼<br>反正我们是把编译错误的代码一份份的点开看了一遍，都没有发现问题</p><p>具体还要等待选手申诉看看还有没有什么锅，明年继续完善</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整整五天五夜，每个环节都差点出事情，幸好在一些最后关头都如有神助，网络通了，代码找到了。。。<br>没有周老师在我扛不住的时候熬夜干活，没有负责网络的叶同学的鼎力支持，没有余姚中学诸一行老师的火线救援，没有硬件部门的兄弟们一起通宵刻盘<br>本次比赛都没办法顺利举行</p><p>对于现场比赛来说，比赛的体验高于一切</p><p>希望大家通过这次ZJNOIP能感受到体验的重要性</p><p>中学生还是需要更多的机会的，区区一次联赛，实在是少的可怜，而且赛制还这么残酷</p><p>期待着搞一次面向中学生的IOI+ICPC赛制，一定会非常有趣, 至少比COI有趣多了</p><p>下面是一些赛场图片<br><img src="/img/2018noip1.jpg" alt="name"><br><img src="/img/2018noip2.jpg" alt="name"><br><img src="/img/2018noip3.jpg" alt="name"><br><img src="/img/2018noip4.jpg" alt="name"><br><img src="/img/2018noip5.jpg" alt="name"><br><img src="/img/2018noip6.jpg" alt="name"></p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018noip </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/bubble-sort-md/"/>
      <url>/bubble-sort-md/</url>
      <content type="html"><![CDATA[<h1 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h1><blockquote><p>假设我们现在要按照从小到大的顺序排,每一轮我们都比较相邻元素的大小,如果前面的元素比较大,就交换,那么第一轮下来最大的数字肯定能跑到最后面去,接下来的每一轮我们都这样执行,那么第二轮,第二大的数会跑到倒数第二个数的位置去…第三轮..,n-1轮之后,整个序列就会变成有序的,每次相当于冒出一个最大的数来,因此叫做冒泡排序<br>复杂度<br>$$<br>O(n^2)<br>$$</p></blockquote><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[1010];int main() {    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) {        scanf(&quot;%d&quot;, &amp;a[i]);    }    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n - i - 1 ; j++) { //最后面i个数是已经冒出来的i个数，不用再比较了            if (a[j] &gt; a[j + 1]) {                swap(a[j], a[j + 1]);            }        }    }    for (int i = 0; i &lt; n; i++) {        printf(&quot;%d &quot;, a[i]);    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 普及 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我从哪里来</title>
      <link href="/hexo-github/"/>
      <url>/hexo-github/</url>
      <content type="html"><![CDATA[<h1 id="linux下安装环境"><a href="#linux下安装环境" class="headerlink" title="linux下安装环境"></a>linux下安装环境</h1><blockquote><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs下载</a></li><li>下载之后解压到合适的目录，假设放到/home/xjoi/nodejs/下</li></ul></blockquote><pre><code>sudo gedit /etc/profile# 在底部添加export NODE_HOME=/home/xjoi/nodejs/node-v10.13.0-linux-x64/binexport PATH=$NODE_HOME:$PATH保存退出sudo source /etc/profile验证版本node -vnpm -v安装hexo: npm i -g hexo &amp;&amp; npm install hexo --save</code></pre><h1 id="github-相关"><a href="#github-相关" class="headerlink" title="github 相关"></a>github 相关</h1><p>注册github账号,注意验证好邮箱<br>假设账号名字为yourname<br>在你的github中新建一个仓库,名字为 yourname.github.io</p><p>打开gitbash</p><pre><code>git config --global user.name &quot;账户名&quot;git config --global user.email &quot;github验证的邮箱名&quot;ssh-keygen -t rsa -C &quot;github验证的邮箱名&quot; (默认按回车即可)</code></pre><p>将~/.ssh/id_rsa.pub中的内容复制到github网页端-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key<br>完成后在bash中输入</p><pre><code>ssh -T git@github.com输入yes即可</code></pre><p>设置成功返回</p><pre><code>Hi xxxxxxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><pre><code>hexo init myblogcd mybloghexo s</code></pre><p>打开<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a> 检验是否初始化成功</p><h1 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h1><p>在themes文件夹里面放上主题文件,比如3-hexo主题</p><pre><code>git clone https://github.com/xjoi/hexo-theme-3-hexo themes/3-hexo</code></pre><p>修改 myblog/_config.yml文件,将theme后面的landscape改为3-hexo,更多主题参考<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网</a></p><pre><code>hexo g &amp;&amp; hexo s</code></pre><p>输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>, 查看主题是否加载成功</p><h1 id="将博客部署到github上"><a href="#将博客部署到github上" class="headerlink" title="将博客部署到github上"></a>将博客部署到github上</h1><p>在myblog目录下安装hexo-deployer-git</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>修改myblog/_config.yml最后几行,注意空格要严格一样</p><pre><code>deploy:  type: git  repo: https://github.com/yourname/yourname.github.io.git  branch: master</code></pre><p>部署</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>稍等一会儿在浏览器中输入yourname.github.io查看是否发布成功</p><h1 id="设置博客模板"><a href="#设置博客模板" class="headerlink" title="设置博客模板"></a>设置博客模板</h1><p>修改 scaffolds下的post.md</p><pre><code>---title: {{ title }}date: {{ date }}categories:tags:---</code></pre><h1 id="发表博客"><a href="#发表博客" class="headerlink" title="发表博客"></a>发表博客</h1><pre><code>hexo new post xxx</code></pre><p>会自动生成一个以xxx为title的markdown文件,编辑这个文件即可</p><h1 id="网站的备份"><a href="#网站的备份" class="headerlink" title="网站的备份"></a>网站的备份</h1><p>发布到github上面的内容是不带原有的markdown文件的,发布的是解析后的html文件</p><p>因此为了满足异地的写作与发布,我们应该要将本地的内容以及相关的配置备份一下</p><p><a href="https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/" target="_blank" rel="noopener">备份</a></p><pre><code>git clone https://github.com/yourgithubname/yourgithubname.github.comcd yourgithubnamenpm install hexo-clinpm installnpm install hexo-deployer-git</code></pre><h1 id="网站信息修改"><a href="#网站信息修改" class="headerlink" title="网站信息修改"></a>网站信息修改</h1><p>编辑myblog/_config.yml文件</p><pre><code>title: 网站名字author: 作者url: 网站网址</code></pre><h1 id="文末声明"><a href="#文末声明" class="headerlink" title="文末声明"></a>文末声明</h1><p>编辑<code>3-hexo/_config.yml</code>文件,找到文末声明的地方,修改自己的邮箱</p><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>编辑 <code>node_modules\marked\lib\marked.js</code> 脚本<br>处理markdown与mathjax的冲突<br>如果要显示数学公式,可以在最开头加上mathjax: true</p><pre><code>451行左右(随着版本的更新可能有波动)escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/,改为escape: /^\\([`*\[\]()# +\-.!_&gt;])/,459行左右em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,改为em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><p>首先关闭myblog/_config.yml中的高亮设置</p><pre><code>highlight:  enable: false</code></pre><p>配置3-hexo/_config.yml中的高亮设置：</p><pre><code>highlight:  on: true # true开启代码高亮  lineNum: true # true显示行号  theme: atom-dark</code></pre><h1 id="头像与文章列表背景"><a href="#头像与文章列表背景" class="headerlink" title="头像与文章列表背景"></a>头像与文章列表背景</h1><blockquote><p>替换themes/3-hexo/source/img 下面的avatar.jpg (头像)<br>替换themes/3-hexo/source/img 下面的background.jpg(文章列表背景图片)</p></blockquote><h1 id="友链与评论"><a href="#友链与评论" class="headerlink" title="友链与评论"></a>友链与评论</h1><p>编辑themes/3-hexo/_config.yml文件</p><blockquote><p>链接图标link: 修改github地址<br>友情链接friends: 增加自己朋友的blog地址<br>评论: comment : 开启设置为true, 选择gitalk ,在下方gitalk下面填入相应信息</p><pre><code>注册: https://github.com/settings/applications/new</code></pre></blockquote><p><img src="/img/auth.png" alt="image"></p><p>编辑3-hexo/_config.yml</p><pre><code>gitalk:  githubID: xjoi #git账户名  repo: xjoi.github.io #仓库名  ClientID: af0e91f8b3e07b208cc7 #上一步得到的信息  ClientSecret: 20b655d18155c0ee2c3093b8be4b91f15d444c3b  adminUser: becauseofyou # 仓库管理员账号名</code></pre><h1 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h1><p>找到3-hexo/_config.yml 中searchAll: 有提示</p><pre><code>searchAll: true# true 启用全文搜索# 开启此功能需要下面操作：# 1. 在 hexo 根目录 执行 npm install hexo-generator-search --save 安装插件# 2. 在 hexo 根目录的 _config.xml 中添加下面内容# search:#   path: search.xml#   field: post</code></pre><h1 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h1><p>同上</p><pre><code>word_count: true# true 开启字数统计# 开启此功能需要安装插件 ：在 hexo根目录 执行npm i hexo-wordcount --save</code></pre><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片放在/img目录下面，引用的时候只需要</p><pre><code>![name](/img/test.png)</code></pre>]]></content>
      
      <categories>
          
          <category> 辅助技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
